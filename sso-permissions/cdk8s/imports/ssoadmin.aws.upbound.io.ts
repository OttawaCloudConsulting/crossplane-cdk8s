// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * AccountAssignment is the Schema for the AccountAssignments API. Manages a Single Sign-On (SSO) Account Assignment
 *
 * @schema AccountAssignment
 */
export class AccountAssignment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "AccountAssignment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'AccountAssignment',
  }

  /**
   * Renders a Kubernetes manifest for "AccountAssignment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AccountAssignmentProps): any {
    return {
      ...AccountAssignment.GVK,
      ...toJson_AccountAssignmentProps(props),
    };
  }

  /**
   * Defines a "AccountAssignment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AccountAssignmentProps) {
    super(scope, id, {
      ...AccountAssignment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AccountAssignment.GVK,
      ...toJson_AccountAssignmentProps(resolved),
    };
  }
}

/**
 * AccountAssignment is the Schema for the AccountAssignments API. Manages a Single Sign-On (SSO) Account Assignment
 *
 * @schema AccountAssignment
 */
export interface AccountAssignmentProps {
  /**
   * @schema AccountAssignment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AccountAssignmentSpec defines the desired state of AccountAssignment
   *
   * @schema AccountAssignment#spec
   */
  readonly spec: AccountAssignmentSpec;

}

/**
 * Converts an object of type 'AccountAssignmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentProps(obj: AccountAssignmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AccountAssignmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccountAssignmentSpec defines the desired state of AccountAssignment
 *
 * @schema AccountAssignmentSpec
 */
export interface AccountAssignmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema AccountAssignmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: AccountAssignmentSpecDeletionPolicy;

  /**
   * @schema AccountAssignmentSpec#forProvider
   */
  readonly forProvider: AccountAssignmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema AccountAssignmentSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema AccountAssignmentSpec#managementPolicies
   */
  readonly managementPolicies?: AccountAssignmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema AccountAssignmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: AccountAssignmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema AccountAssignmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: AccountAssignmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema AccountAssignmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: AccountAssignmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'AccountAssignmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpec(obj: AccountAssignmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_AccountAssignmentSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_AccountAssignmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_AccountAssignmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_AccountAssignmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema AccountAssignmentSpecDeletionPolicy
 */
export enum AccountAssignmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema AccountAssignmentSpecForProvider
 */
export interface AccountAssignmentSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance.
   *
   * @schema AccountAssignmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set that the admin wants to grant the principal access to.
   *
   * @schema AccountAssignmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema AccountAssignmentSpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: AccountAssignmentSpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema AccountAssignmentSpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: AccountAssignmentSpecForProviderPermissionSetArnSelector;

  /**
   * An identifier for an object in SSO, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). This can be set to the crossplane external-name of either a Group or User in the identitystore api group, but the Ref and Selector fields will only work with a Group.
   *
   * @schema AccountAssignmentSpecForProvider#principalId
   */
  readonly principalId?: string;

  /**
   * Reference to a Group in identitystore to populate principalId.
   *
   * @schema AccountAssignmentSpecForProvider#principalIdFromGroupRef
   */
  readonly principalIdFromGroupRef?: AccountAssignmentSpecForProviderPrincipalIdFromGroupRef;

  /**
   * Selector for a Group in identitystore to populate principalId.
   *
   * @schema AccountAssignmentSpecForProvider#principalIdFromGroupSelector
   */
  readonly principalIdFromGroupSelector?: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector;

  /**
   * The entity type for which the assignment will be created. Valid values: USER, GROUP.
   *
   * @schema AccountAssignmentSpecForProvider#principalType
   */
  readonly principalType: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema AccountAssignmentSpecForProvider#region
   */
  readonly region: string;

  /**
   * An AWS account identifier, typically a 10-12 digit string.
   *
   * @schema AccountAssignmentSpecForProvider#targetId
   */
  readonly targetId: string;

  /**
   * The entity type for which the assignment will be created. Valid values: AWS_ACCOUNT.
   *
   * @schema AccountAssignmentSpecForProvider#targetType
   */
  readonly targetType?: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProvider(obj: AccountAssignmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_AccountAssignmentSpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_AccountAssignmentSpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'principalId': obj.principalId,
    'principalIdFromGroupRef': toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupRef(obj.principalIdFromGroupRef),
    'principalIdFromGroupSelector': toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector(obj.principalIdFromGroupSelector),
    'principalType': obj.principalType,
    'region': obj.region,
    'targetId': obj.targetId,
    'targetType': obj.targetType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema AccountAssignmentSpecManagementPolicies
 */
export enum AccountAssignmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema AccountAssignmentSpecProviderConfigRef
 */
export interface AccountAssignmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecProviderConfigRef#policy
   */
  readonly policy?: AccountAssignmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderConfigRef(obj: AccountAssignmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsTo
 */
export interface AccountAssignmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: AccountAssignmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: AccountAssignmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsTo(obj: AccountAssignmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_AccountAssignmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema AccountAssignmentSpecWriteConnectionSecretToRef
 */
export interface AccountAssignmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema AccountAssignmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema AccountAssignmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecWriteConnectionSecretToRef(obj: AccountAssignmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnRef
 */
export interface AccountAssignmentSpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: AccountAssignmentSpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPermissionSetArnRef(obj: AccountAssignmentSpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnSelector
 */
export interface AccountAssignmentSpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPermissionSetArnSelector(obj: AccountAssignmentSpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in identitystore to populate principalId.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRef
 */
export interface AccountAssignmentSpecForProviderPrincipalIdFromGroupRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRef#policy
   */
  readonly policy?: AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPrincipalIdFromGroupRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupRef(obj: AccountAssignmentSpecForProviderPrincipalIdFromGroupRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in identitystore to populate principalId.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector
 */
export interface AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector#policy
   */
  readonly policy?: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector(obj: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicy
 */
export interface AccountAssignmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecProviderConfigRefPolicy(obj: AccountAssignmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRef(obj: AccountAssignmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToMetadata(obj: AccountAssignmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnRefPolicy
 */
export interface AccountAssignmentSpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPermissionSetArnRefPolicy(obj: AccountAssignmentSpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy
 */
export interface AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy(obj: AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy
 */
export interface AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy(obj: AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy
 */
export interface AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy(obj: AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicyResolution
 */
export enum AccountAssignmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecProviderConfigRefPolicyResolve
 */
export enum AccountAssignmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum AccountAssignmentSpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum AccountAssignmentSpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolution
 */
export enum AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolve
 */
export enum AccountAssignmentSpecForProviderPrincipalIdFromGroupRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolution
 */
export enum AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolve
 */
export enum AccountAssignmentSpecForProviderPrincipalIdFromGroupSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum AccountAssignmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomerManagedPolicyAttachment is the Schema for the CustomerManagedPolicyAttachments API. Manages a customer managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema CustomerManagedPolicyAttachment
 */
export class CustomerManagedPolicyAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomerManagedPolicyAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'CustomerManagedPolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "CustomerManagedPolicyAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomerManagedPolicyAttachmentProps): any {
    return {
      ...CustomerManagedPolicyAttachment.GVK,
      ...toJson_CustomerManagedPolicyAttachmentProps(props),
    };
  }

  /**
   * Defines a "CustomerManagedPolicyAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomerManagedPolicyAttachmentProps) {
    super(scope, id, {
      ...CustomerManagedPolicyAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomerManagedPolicyAttachment.GVK,
      ...toJson_CustomerManagedPolicyAttachmentProps(resolved),
    };
  }
}

/**
 * CustomerManagedPolicyAttachment is the Schema for the CustomerManagedPolicyAttachments API. Manages a customer managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema CustomerManagedPolicyAttachment
 */
export interface CustomerManagedPolicyAttachmentProps {
  /**
   * @schema CustomerManagedPolicyAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomerManagedPolicyAttachmentSpec defines the desired state of CustomerManagedPolicyAttachment
   *
   * @schema CustomerManagedPolicyAttachment#spec
   */
  readonly spec: CustomerManagedPolicyAttachmentSpec;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentProps(obj: CustomerManagedPolicyAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomerManagedPolicyAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomerManagedPolicyAttachmentSpec defines the desired state of CustomerManagedPolicyAttachment
 *
 * @schema CustomerManagedPolicyAttachmentSpec
 */
export interface CustomerManagedPolicyAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomerManagedPolicyAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: CustomerManagedPolicyAttachmentSpecDeletionPolicy;

  /**
   * @schema CustomerManagedPolicyAttachmentSpec#forProvider
   */
  readonly forProvider: CustomerManagedPolicyAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema CustomerManagedPolicyAttachmentSpec#initProvider
   */
  readonly initProvider?: CustomerManagedPolicyAttachmentSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CustomerManagedPolicyAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: CustomerManagedPolicyAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema CustomerManagedPolicyAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: CustomerManagedPolicyAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema CustomerManagedPolicyAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema CustomerManagedPolicyAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpec(obj: CustomerManagedPolicyAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomerManagedPolicyAttachmentSpecForProvider(obj.forProvider),
    'initProvider': toJson_CustomerManagedPolicyAttachmentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CustomerManagedPolicyAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomerManagedPolicyAttachmentSpecDeletionPolicy
 */
export enum CustomerManagedPolicyAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomerManagedPolicyAttachmentSpecForProvider
 */
export interface CustomerManagedPolicyAttachmentSpecForProvider {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference[];

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProvider(obj: CustomerManagedPolicyAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': obj.customerManagedPolicyReference?.map(y => toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference(y)),
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProvider
 */
export interface CustomerManagedPolicyAttachmentSpecInitProvider {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProvider#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference[];

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProvider(obj: CustomerManagedPolicyAttachmentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': obj.customerManagedPolicyReference?.map(y => toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema CustomerManagedPolicyAttachmentSpecManagementPolicies
 */
export enum CustomerManagedPolicyAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRef
 */
export interface CustomerManagedPolicyAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecProviderConfigRef(obj: CustomerManagedPolicyAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo
 */
export interface CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef
 */
export interface CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj: CustomerManagedPolicyAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference#path
   */
  readonly path?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference#policyNameRef
   */
  readonly policyNameRef?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference#policyNameSelector
   */
  readonly policyNameSelector?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference(obj: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'policyNameRef': toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef(obj.policyNameRef),
    'policyNameSelector': toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector(obj.policyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference
 */
export interface CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference#path
   */
  readonly path?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference#policyNameRef
   */
  readonly policyNameRef?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference#policyNameSelector
   */
  readonly policyNameSelector?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference(obj: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'policyNameRef': toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef(obj.policyNameRef),
    'policyNameSelector': toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector(obj.policyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj: CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef(obj: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector(obj: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj: CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef
 */
export interface CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef(obj: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector
 */
export interface CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector(obj: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj: CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj: CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentSpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * CustomerManagedPolicyAttachment is the Schema for the CustomerManagedPolicyAttachments API. Manages a customer managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2
 */
export class CustomerManagedPolicyAttachmentV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomerManagedPolicyAttachmentV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta2',
    kind: 'CustomerManagedPolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "CustomerManagedPolicyAttachmentV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomerManagedPolicyAttachmentV1Beta2Props): any {
    return {
      ...CustomerManagedPolicyAttachmentV1Beta2.GVK,
      ...toJson_CustomerManagedPolicyAttachmentV1Beta2Props(props),
    };
  }

  /**
   * Defines a "CustomerManagedPolicyAttachmentV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomerManagedPolicyAttachmentV1Beta2Props) {
    super(scope, id, {
      ...CustomerManagedPolicyAttachmentV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomerManagedPolicyAttachmentV1Beta2.GVK,
      ...toJson_CustomerManagedPolicyAttachmentV1Beta2Props(resolved),
    };
  }
}

/**
 * CustomerManagedPolicyAttachment is the Schema for the CustomerManagedPolicyAttachments API. Manages a customer managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2
 */
export interface CustomerManagedPolicyAttachmentV1Beta2Props {
  /**
   * @schema CustomerManagedPolicyAttachmentV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomerManagedPolicyAttachmentSpec defines the desired state of CustomerManagedPolicyAttachment
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2#spec
   */
  readonly spec: CustomerManagedPolicyAttachmentV1Beta2Spec;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2Props(obj: CustomerManagedPolicyAttachmentV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomerManagedPolicyAttachmentV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CustomerManagedPolicyAttachmentSpec defines the desired state of CustomerManagedPolicyAttachment
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2Spec
 */
export interface CustomerManagedPolicyAttachmentV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: CustomerManagedPolicyAttachmentV1Beta2SpecDeletionPolicy;

  /**
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#forProvider
   */
  readonly forProvider: CustomerManagedPolicyAttachmentV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#initProvider
   */
  readonly initProvider?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: CustomerManagedPolicyAttachmentV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2Spec(obj: CustomerManagedPolicyAttachmentV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecDeletionPolicy
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProvider {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProvider(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference(obj.customerManagedPolicyReference),
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference(obj.customerManagedPolicyReference),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecManagementPolicies
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo(obj: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the name and path of a customer managed policy. See below.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference#path
   */
  readonly path?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference#policyNameRef
   */
  readonly policyNameRef?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference#policyNameSelector
   */
  readonly policyNameSelector?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'policyNameRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef(obj.policyNameRef),
    'policyNameSelector': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector(obj.policyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the name and path of a customer managed policy. See below.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference#path
   */
  readonly path?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference#policyNameRef
   */
  readonly policyNameRef?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference#policyNameSelector
   */
  readonly policyNameSelector?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'path': obj.path,
    'policyNameRef': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef(obj.policyNameRef),
    'policyNameSelector': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector(obj.policyNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata(obj: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector#policy
   */
  readonly policy?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy
 */
export interface CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolution
   */
  readonly resolution?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy#resolve
   */
  readonly resolve?: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy(obj: CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecForProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve
 */
export enum CustomerManagedPolicyAttachmentV1Beta2SpecInitProviderCustomerManagedPolicyReferencePolicyNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * InstanceAccessControlAttributes is the Schema for the InstanceAccessControlAttributess API. Provides a Single Sign-On (SSO) ABAC Resource: https://docs.aws.amazon.com/singlesignon/latest/userguide/abac.html
 *
 * @schema InstanceAccessControlAttributes
 */
export class InstanceAccessControlAttributes extends ApiObject {
  /**
   * Returns the apiVersion and kind for "InstanceAccessControlAttributes"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'InstanceAccessControlAttributes',
  }

  /**
   * Renders a Kubernetes manifest for "InstanceAccessControlAttributes".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: InstanceAccessControlAttributesProps): any {
    return {
      ...InstanceAccessControlAttributes.GVK,
      ...toJson_InstanceAccessControlAttributesProps(props),
    };
  }

  /**
   * Defines a "InstanceAccessControlAttributes" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: InstanceAccessControlAttributesProps) {
    super(scope, id, {
      ...InstanceAccessControlAttributes.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...InstanceAccessControlAttributes.GVK,
      ...toJson_InstanceAccessControlAttributesProps(resolved),
    };
  }
}

/**
 * InstanceAccessControlAttributes is the Schema for the InstanceAccessControlAttributess API. Provides a Single Sign-On (SSO) ABAC Resource: https://docs.aws.amazon.com/singlesignon/latest/userguide/abac.html
 *
 * @schema InstanceAccessControlAttributes
 */
export interface InstanceAccessControlAttributesProps {
  /**
   * @schema InstanceAccessControlAttributes#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * InstanceAccessControlAttributesSpec defines the desired state of InstanceAccessControlAttributes
   *
   * @schema InstanceAccessControlAttributes#spec
   */
  readonly spec: InstanceAccessControlAttributesSpec;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesProps(obj: InstanceAccessControlAttributesProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_InstanceAccessControlAttributesSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * InstanceAccessControlAttributesSpec defines the desired state of InstanceAccessControlAttributes
 *
 * @schema InstanceAccessControlAttributesSpec
 */
export interface InstanceAccessControlAttributesSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema InstanceAccessControlAttributesSpec#deletionPolicy
   */
  readonly deletionPolicy?: InstanceAccessControlAttributesSpecDeletionPolicy;

  /**
   * @schema InstanceAccessControlAttributesSpec#forProvider
   */
  readonly forProvider: InstanceAccessControlAttributesSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema InstanceAccessControlAttributesSpec#initProvider
   */
  readonly initProvider?: InstanceAccessControlAttributesSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema InstanceAccessControlAttributesSpec#managementPolicies
   */
  readonly managementPolicies?: InstanceAccessControlAttributesSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema InstanceAccessControlAttributesSpec#providerConfigRef
   */
  readonly providerConfigRef?: InstanceAccessControlAttributesSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema InstanceAccessControlAttributesSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: InstanceAccessControlAttributesSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema InstanceAccessControlAttributesSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: InstanceAccessControlAttributesSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpec(obj: InstanceAccessControlAttributesSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_InstanceAccessControlAttributesSpecForProvider(obj.forProvider),
    'initProvider': toJson_InstanceAccessControlAttributesSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_InstanceAccessControlAttributesSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_InstanceAccessControlAttributesSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema InstanceAccessControlAttributesSpecDeletionPolicy
 */
export enum InstanceAccessControlAttributesSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema InstanceAccessControlAttributesSpecForProvider
 */
export interface InstanceAccessControlAttributesSpecForProvider {
  /**
   * See AccessControlAttribute for more details.
   *
   * @schema InstanceAccessControlAttributesSpecForProvider#attribute
   */
  readonly attribute?: InstanceAccessControlAttributesSpecForProviderAttribute[];

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance.
   *
   * @schema InstanceAccessControlAttributesSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema InstanceAccessControlAttributesSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecForProvider(obj: InstanceAccessControlAttributesSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute?.map(y => toJson_InstanceAccessControlAttributesSpecForProviderAttribute(y)),
    'instanceArn': obj.instanceArn,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema InstanceAccessControlAttributesSpecInitProvider
 */
export interface InstanceAccessControlAttributesSpecInitProvider {
  /**
   * See AccessControlAttribute for more details.
   *
   * @schema InstanceAccessControlAttributesSpecInitProvider#attribute
   */
  readonly attribute?: InstanceAccessControlAttributesSpecInitProviderAttribute[];

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecInitProvider(obj: InstanceAccessControlAttributesSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'attribute': obj.attribute?.map(y => toJson_InstanceAccessControlAttributesSpecInitProviderAttribute(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema InstanceAccessControlAttributesSpecManagementPolicies
 */
export enum InstanceAccessControlAttributesSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema InstanceAccessControlAttributesSpecProviderConfigRef
 */
export interface InstanceAccessControlAttributesSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceAccessControlAttributesSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceAccessControlAttributesSpecProviderConfigRef#policy
   */
  readonly policy?: InstanceAccessControlAttributesSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecProviderConfigRef(obj: InstanceAccessControlAttributesSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceAccessControlAttributesSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsTo
 */
export interface InstanceAccessControlAttributesSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsTo(obj: InstanceAccessControlAttributesSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema InstanceAccessControlAttributesSpecWriteConnectionSecretToRef
 */
export interface InstanceAccessControlAttributesSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema InstanceAccessControlAttributesSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema InstanceAccessControlAttributesSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecWriteConnectionSecretToRef(obj: InstanceAccessControlAttributesSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceAccessControlAttributesSpecForProviderAttribute
 */
export interface InstanceAccessControlAttributesSpecForProviderAttribute {
  /**
   * The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in AWS SSO.
   *
   * @schema InstanceAccessControlAttributesSpecForProviderAttribute#key
   */
  readonly key?: string;

  /**
   * The value used for mapping a specified attribute to an identity source. See AccessControlAttributeValue
   *
   * @schema InstanceAccessControlAttributesSpecForProviderAttribute#value
   */
  readonly value?: InstanceAccessControlAttributesSpecForProviderAttributeValue[];

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecForProviderAttribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecForProviderAttribute(obj: InstanceAccessControlAttributesSpecForProviderAttribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value?.map(y => toJson_InstanceAccessControlAttributesSpecForProviderAttributeValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceAccessControlAttributesSpecInitProviderAttribute
 */
export interface InstanceAccessControlAttributesSpecInitProviderAttribute {
  /**
   * The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in AWS SSO.
   *
   * @schema InstanceAccessControlAttributesSpecInitProviderAttribute#key
   */
  readonly key?: string;

  /**
   * The value used for mapping a specified attribute to an identity source. See AccessControlAttributeValue
   *
   * @schema InstanceAccessControlAttributesSpecInitProviderAttribute#value
   */
  readonly value?: InstanceAccessControlAttributesSpecInitProviderAttributeValue[];

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecInitProviderAttribute' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecInitProviderAttribute(obj: InstanceAccessControlAttributesSpecInitProviderAttribute | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value?.map(y => toJson_InstanceAccessControlAttributesSpecInitProviderAttributeValue(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema InstanceAccessControlAttributesSpecProviderConfigRefPolicy
 */
export interface InstanceAccessControlAttributesSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema InstanceAccessControlAttributesSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema InstanceAccessControlAttributesSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecProviderConfigRefPolicy(obj: InstanceAccessControlAttributesSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef
 */
export interface InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef(obj: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata
 */
export interface InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata(obj: InstanceAccessControlAttributesSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceAccessControlAttributesSpecForProviderAttributeValue
 */
export interface InstanceAccessControlAttributesSpecForProviderAttributeValue {
  /**
   * The identity source to use when mapping a specified attribute to AWS SSO.
   *
   * @schema InstanceAccessControlAttributesSpecForProviderAttributeValue#source
   */
  readonly source?: string[];

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecForProviderAttributeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecForProviderAttributeValue(obj: InstanceAccessControlAttributesSpecForProviderAttributeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema InstanceAccessControlAttributesSpecInitProviderAttributeValue
 */
export interface InstanceAccessControlAttributesSpecInitProviderAttributeValue {
  /**
   * The identity source to use when mapping a specified attribute to AWS SSO.
   *
   * @schema InstanceAccessControlAttributesSpecInitProviderAttributeValue#source
   */
  readonly source?: string[];

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecInitProviderAttributeValue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecInitProviderAttributeValue(obj: InstanceAccessControlAttributesSpecInitProviderAttributeValue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolution
 */
export enum InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolve
 */
export enum InstanceAccessControlAttributesSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy(obj: InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum InstanceAccessControlAttributesSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ManagedPolicyAttachment is the Schema for the ManagedPolicyAttachments API. Manages an IAM managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema ManagedPolicyAttachment
 */
export class ManagedPolicyAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ManagedPolicyAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'ManagedPolicyAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "ManagedPolicyAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ManagedPolicyAttachmentProps): any {
    return {
      ...ManagedPolicyAttachment.GVK,
      ...toJson_ManagedPolicyAttachmentProps(props),
    };
  }

  /**
   * Defines a "ManagedPolicyAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ManagedPolicyAttachmentProps) {
    super(scope, id, {
      ...ManagedPolicyAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ManagedPolicyAttachment.GVK,
      ...toJson_ManagedPolicyAttachmentProps(resolved),
    };
  }
}

/**
 * ManagedPolicyAttachment is the Schema for the ManagedPolicyAttachments API. Manages an IAM managed policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema ManagedPolicyAttachment
 */
export interface ManagedPolicyAttachmentProps {
  /**
   * @schema ManagedPolicyAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ManagedPolicyAttachmentSpec defines the desired state of ManagedPolicyAttachment
   *
   * @schema ManagedPolicyAttachment#spec
   */
  readonly spec: ManagedPolicyAttachmentSpec;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentProps(obj: ManagedPolicyAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ManagedPolicyAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ManagedPolicyAttachmentSpec defines the desired state of ManagedPolicyAttachment
 *
 * @schema ManagedPolicyAttachmentSpec
 */
export interface ManagedPolicyAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ManagedPolicyAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: ManagedPolicyAttachmentSpecDeletionPolicy;

  /**
   * @schema ManagedPolicyAttachmentSpec#forProvider
   */
  readonly forProvider: ManagedPolicyAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ManagedPolicyAttachmentSpec#initProvider
   */
  readonly initProvider?: any;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ManagedPolicyAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: ManagedPolicyAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ManagedPolicyAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: ManagedPolicyAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ManagedPolicyAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ManagedPolicyAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ManagedPolicyAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ManagedPolicyAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpec(obj: ManagedPolicyAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ManagedPolicyAttachmentSpecForProvider(obj.forProvider),
    'initProvider': obj.initProvider,
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ManagedPolicyAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ManagedPolicyAttachmentSpecDeletionPolicy
 */
export enum ManagedPolicyAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ManagedPolicyAttachmentSpecForProvider
 */
export interface ManagedPolicyAttachmentSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The IAM managed policy Amazon Resource Name (ARN) to be attached to the Permission Set.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#managedPolicyArn
   */
  readonly managedPolicyArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ManagedPolicyAttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProvider(obj: ManagedPolicyAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'managedPolicyArn': obj.managedPolicyArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ManagedPolicyAttachmentSpecManagementPolicies
 */
export enum ManagedPolicyAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRef
 */
export interface ManagedPolicyAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderConfigRef(obj: ManagedPolicyAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsTo(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef
 */
export interface ManagedPolicyAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ManagedPolicyAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecWriteConnectionSecretToRef(obj: ManagedPolicyAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy
 */
export interface ManagedPolicyAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecProviderConfigRefPolicy(obj: ManagedPolicyAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy
 */
export interface ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj: ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ManagedPolicyAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionsBoundaryAttachment is the Schema for the PermissionsBoundaryAttachments API. Attaches a permissions boundary policy to a Single Sign-On (SSO) Permission Set resource.
 *
 * @schema PermissionsBoundaryAttachment
 */
export class PermissionsBoundaryAttachment extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionsBoundaryAttachment"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'PermissionsBoundaryAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionsBoundaryAttachment".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionsBoundaryAttachmentProps): any {
    return {
      ...PermissionsBoundaryAttachment.GVK,
      ...toJson_PermissionsBoundaryAttachmentProps(props),
    };
  }

  /**
   * Defines a "PermissionsBoundaryAttachment" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionsBoundaryAttachmentProps) {
    super(scope, id, {
      ...PermissionsBoundaryAttachment.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionsBoundaryAttachment.GVK,
      ...toJson_PermissionsBoundaryAttachmentProps(resolved),
    };
  }
}

/**
 * PermissionsBoundaryAttachment is the Schema for the PermissionsBoundaryAttachments API. Attaches a permissions boundary policy to a Single Sign-On (SSO) Permission Set resource.
 *
 * @schema PermissionsBoundaryAttachment
 */
export interface PermissionsBoundaryAttachmentProps {
  /**
   * @schema PermissionsBoundaryAttachment#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionsBoundaryAttachmentSpec defines the desired state of PermissionsBoundaryAttachment
   *
   * @schema PermissionsBoundaryAttachment#spec
   */
  readonly spec: PermissionsBoundaryAttachmentSpec;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentProps(obj: PermissionsBoundaryAttachmentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionsBoundaryAttachmentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionsBoundaryAttachmentSpec defines the desired state of PermissionsBoundaryAttachment
 *
 * @schema PermissionsBoundaryAttachmentSpec
 */
export interface PermissionsBoundaryAttachmentSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionsBoundaryAttachmentSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionsBoundaryAttachmentSpecDeletionPolicy;

  /**
   * @schema PermissionsBoundaryAttachmentSpec#forProvider
   */
  readonly forProvider: PermissionsBoundaryAttachmentSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema PermissionsBoundaryAttachmentSpec#initProvider
   */
  readonly initProvider?: PermissionsBoundaryAttachmentSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionsBoundaryAttachmentSpec#managementPolicies
   */
  readonly managementPolicies?: PermissionsBoundaryAttachmentSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema PermissionsBoundaryAttachmentSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionsBoundaryAttachmentSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema PermissionsBoundaryAttachmentSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema PermissionsBoundaryAttachmentSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpec(obj: PermissionsBoundaryAttachmentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionsBoundaryAttachmentSpecForProvider(obj.forProvider),
    'initProvider': toJson_PermissionsBoundaryAttachmentSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionsBoundaryAttachmentSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionsBoundaryAttachmentSpecDeletionPolicy
 */
export enum PermissionsBoundaryAttachmentSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionsBoundaryAttachmentSpecForProvider
 */
export interface PermissionsBoundaryAttachmentSpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector;

  /**
   * The permissions boundary policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#permissionsBoundary
   */
  readonly permissionsBoundary?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary[];

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProvider(obj: PermissionsBoundaryAttachmentSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'permissionsBoundary': obj.permissionsBoundary?.map(y => toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary(y)),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProvider
 */
export interface PermissionsBoundaryAttachmentSpecInitProvider {
  /**
   * The permissions boundary policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProvider#permissionsBoundary
   */
  readonly permissionsBoundary?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary[];

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProvider(obj: PermissionsBoundaryAttachmentSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissionsBoundary': obj.permissionsBoundary?.map(y => toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema PermissionsBoundaryAttachmentSpecManagementPolicies
 */
export enum PermissionsBoundaryAttachmentSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema PermissionsBoundaryAttachmentSpecProviderConfigRef
 */
export interface PermissionsBoundaryAttachmentSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecProviderConfigRef(obj: PermissionsBoundaryAttachmentSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo
 */
export interface PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo(obj: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef
 */
export interface PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef(obj: PermissionsBoundaryAttachmentSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference[];

  /**
   * AWS-managed IAM policy ARN to use as the permissions boundary.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary#managedPolicyArn
   */
  readonly managedPolicyArn?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': obj.customerManagedPolicyReference?.map(y => toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference(y)),
    'managedPolicyArn': obj.managedPolicyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference[];

  /**
   * AWS-managed IAM policy ARN to use as the permissions boundary.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary#managedPolicyArn
   */
  readonly managedPolicyArn?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': obj.customerManagedPolicyReference?.map(y => toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference(y)),
    'managedPolicyArn': obj.managedPolicyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy
 */
export interface PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy(obj: PermissionsBoundaryAttachmentSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef(obj: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata(obj: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#nameRef
   */
  readonly nameRef?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#nameSelector
   */
  readonly nameSelector?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj.nameSelector),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#nameRef
   */
  readonly nameRef?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#nameSelector
   */
  readonly nameSelector?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj.nameSelector),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj: PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj: PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentSpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionsBoundaryAttachment is the Schema for the PermissionsBoundaryAttachments API. Attaches a permissions boundary policy to a Single Sign-On (SSO) Permission Set resource.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2
 */
export class PermissionsBoundaryAttachmentV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionsBoundaryAttachmentV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta2',
    kind: 'PermissionsBoundaryAttachment',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionsBoundaryAttachmentV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionsBoundaryAttachmentV1Beta2Props): any {
    return {
      ...PermissionsBoundaryAttachmentV1Beta2.GVK,
      ...toJson_PermissionsBoundaryAttachmentV1Beta2Props(props),
    };
  }

  /**
   * Defines a "PermissionsBoundaryAttachmentV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionsBoundaryAttachmentV1Beta2Props) {
    super(scope, id, {
      ...PermissionsBoundaryAttachmentV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionsBoundaryAttachmentV1Beta2.GVK,
      ...toJson_PermissionsBoundaryAttachmentV1Beta2Props(resolved),
    };
  }
}

/**
 * PermissionsBoundaryAttachment is the Schema for the PermissionsBoundaryAttachments API. Attaches a permissions boundary policy to a Single Sign-On (SSO) Permission Set resource.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2
 */
export interface PermissionsBoundaryAttachmentV1Beta2Props {
  /**
   * @schema PermissionsBoundaryAttachmentV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionsBoundaryAttachmentSpec defines the desired state of PermissionsBoundaryAttachment
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2#spec
   */
  readonly spec: PermissionsBoundaryAttachmentV1Beta2Spec;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2Props(obj: PermissionsBoundaryAttachmentV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionsBoundaryAttachmentV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionsBoundaryAttachmentSpec defines the desired state of PermissionsBoundaryAttachment
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2Spec
 */
export interface PermissionsBoundaryAttachmentV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionsBoundaryAttachmentV1Beta2SpecDeletionPolicy;

  /**
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#forProvider
   */
  readonly forProvider: PermissionsBoundaryAttachmentV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#initProvider
   */
  readonly initProvider?: PermissionsBoundaryAttachmentV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: PermissionsBoundaryAttachmentV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2Spec(obj: PermissionsBoundaryAttachmentV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecDeletionPolicy
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProvider {
  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector;

  /**
   * The permissions boundary policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#permissionsBoundary
   */
  readonly permissionsBoundary?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProvider(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'permissionsBoundary': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary(obj.permissionsBoundary),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProvider
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProvider {
  /**
   * The permissions boundary policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProvider#permissionsBoundary
   */
  readonly permissionsBoundary?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProvider(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'permissionsBoundary': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary(obj.permissionsBoundary),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecManagementPolicies
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo(obj: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The permissions boundary policy. See below.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference;

  /**
   * AWS-managed IAM policy ARN to use as the permissions boundary.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary#managedPolicyArn
   */
  readonly managedPolicyArn?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference(obj.customerManagedPolicyReference),
    'managedPolicyArn': obj.managedPolicyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The permissions boundary policy. See below.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary {
  /**
   * Specifies the name and path of a customer managed policy. See below.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary#customerManagedPolicyReference
   */
  readonly customerManagedPolicyReference?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference;

  /**
   * AWS-managed IAM policy ARN to use as the permissions boundary.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary#managedPolicyArn
   */
  readonly managedPolicyArn?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundary | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customerManagedPolicyReference': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference(obj.customerManagedPolicyReference),
    'managedPolicyArn': obj.managedPolicyArn,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata(obj: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the name and path of a customer managed policy. See below.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#nameRef
   */
  readonly nameRef?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#nameSelector
   */
  readonly nameSelector?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj.nameSelector),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the name and path of a customer managed policy. See below.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference {
  /**
   * Name of the customer managed IAM Policy to be attached.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#name
   */
  readonly name?: string;

  /**
   * Reference to a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#nameRef
   */
  readonly nameRef?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef;

  /**
   * Selector for a Policy in iam to populate name.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#nameSelector
   */
  readonly nameSelector?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector;

  /**
   * The path to the IAM policy to be attached. The default is /. See IAM Identifiers for more information.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'nameRef': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj.nameRef),
    'nameSelector': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj.nameSelector),
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Policy in iam to populate name.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector#policy
   */
  readonly policy?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy
 */
export interface PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolution
   */
  readonly resolution?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy#resolve
   */
  readonly resolve?: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy(obj: PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecForProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve
 */
export enum PermissionsBoundaryAttachmentV1Beta2SpecInitProviderPermissionsBoundaryCustomerManagedPolicyReferenceNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionSet is the Schema for the PermissionSets API. Manages a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSet
 */
export class PermissionSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'PermissionSet',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionSetProps): any {
    return {
      ...PermissionSet.GVK,
      ...toJson_PermissionSetProps(props),
    };
  }

  /**
   * Defines a "PermissionSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionSetProps) {
    super(scope, id, {
      ...PermissionSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionSet.GVK,
      ...toJson_PermissionSetProps(resolved),
    };
  }
}

/**
 * PermissionSet is the Schema for the PermissionSets API. Manages a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSet
 */
export interface PermissionSetProps {
  /**
   * @schema PermissionSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSetSpec defines the desired state of PermissionSet
   *
   * @schema PermissionSet#spec
   */
  readonly spec: PermissionSetSpec;

}

/**
 * Converts an object of type 'PermissionSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetProps(obj: PermissionSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSetSpec defines the desired state of PermissionSet
 *
 * @schema PermissionSetSpec
 */
export interface PermissionSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSetSpecDeletionPolicy;

  /**
   * @schema PermissionSetSpec#forProvider
   */
  readonly forProvider: PermissionSetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema PermissionSetSpec#initProvider
   */
  readonly initProvider?: PermissionSetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionSetSpec#managementPolicies
   */
  readonly managementPolicies?: PermissionSetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema PermissionSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema PermissionSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema PermissionSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpec(obj: PermissionSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSetSpecForProvider(obj.forProvider),
    'initProvider': toJson_PermissionSetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionSetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetSpecDeletionPolicy
 */
export enum PermissionSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSetSpecForProvider
 */
export interface PermissionSetSpecForProvider {
  /**
   * The description of the Permission Set.
   *
   * @schema PermissionSetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionSetSpecForProvider#instanceArn
   */
  readonly instanceArn?: string;

  /**
   * The name of the Permission Set.
   *
   * @schema PermissionSetSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * The relay state URL used to redirect users within the application during the federation authentication process.
   *
   * @schema PermissionSetSpecForProvider#relayState
   */
  readonly relayState?: string;

  /**
   * The length of time that the application user sessions are valid in the ISO-8601 standard. Default: PT1H.
   *
   * @schema PermissionSetSpecForProvider#sessionDuration
   */
  readonly sessionDuration?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PermissionSetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PermissionSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecForProvider(obj: PermissionSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceArn': obj.instanceArn,
    'name': obj.name,
    'region': obj.region,
    'relayState': obj.relayState,
    'sessionDuration': obj.sessionDuration,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema PermissionSetSpecInitProvider
 */
export interface PermissionSetSpecInitProvider {
  /**
   * The description of the Permission Set.
   *
   * @schema PermissionSetSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionSetSpecInitProvider#instanceArn
   */
  readonly instanceArn?: string;

  /**
   * The name of the Permission Set.
   *
   * @schema PermissionSetSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * The relay state URL used to redirect users within the application during the federation authentication process.
   *
   * @schema PermissionSetSpecInitProvider#relayState
   */
  readonly relayState?: string;

  /**
   * The length of time that the application user sessions are valid in the ISO-8601 standard. Default: PT1H.
   *
   * @schema PermissionSetSpecInitProvider#sessionDuration
   */
  readonly sessionDuration?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema PermissionSetSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'PermissionSetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecInitProvider(obj: PermissionSetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'instanceArn': obj.instanceArn,
    'name': obj.name,
    'relayState': obj.relayState,
    'sessionDuration': obj.sessionDuration,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema PermissionSetSpecManagementPolicies
 */
export enum PermissionSetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema PermissionSetSpecProviderConfigRef
 */
export interface PermissionSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetSpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderConfigRef(obj: PermissionSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsTo
 */
export interface PermissionSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsTo(obj: PermissionSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema PermissionSetSpecWriteConnectionSecretToRef
 */
export interface PermissionSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecWriteConnectionSecretToRef(obj: PermissionSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicy
 */
export interface PermissionSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecProviderConfigRefPolicy(obj: PermissionSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToConfigRef(obj: PermissionSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToMetadata(obj: PermissionSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicyResolution
 */
export enum PermissionSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetSpecProviderConfigRefPolicyResolve
 */
export enum PermissionSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * PermissionSetInlinePolicy is the Schema for the PermissionSetInlinePolicys API. Manages an IAM inline policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSetInlinePolicy
 */
export class PermissionSetInlinePolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PermissionSetInlinePolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'ssoadmin.aws.upbound.io/v1beta1',
    kind: 'PermissionSetInlinePolicy',
  }

  /**
   * Renders a Kubernetes manifest for "PermissionSetInlinePolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PermissionSetInlinePolicyProps): any {
    return {
      ...PermissionSetInlinePolicy.GVK,
      ...toJson_PermissionSetInlinePolicyProps(props),
    };
  }

  /**
   * Defines a "PermissionSetInlinePolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PermissionSetInlinePolicyProps) {
    super(scope, id, {
      ...PermissionSetInlinePolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PermissionSetInlinePolicy.GVK,
      ...toJson_PermissionSetInlinePolicyProps(resolved),
    };
  }
}

/**
 * PermissionSetInlinePolicy is the Schema for the PermissionSetInlinePolicys API. Manages an IAM inline policy for a Single Sign-On (SSO) Permission Set
 *
 * @schema PermissionSetInlinePolicy
 */
export interface PermissionSetInlinePolicyProps {
  /**
   * @schema PermissionSetInlinePolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PermissionSetInlinePolicySpec defines the desired state of PermissionSetInlinePolicy
   *
   * @schema PermissionSetInlinePolicy#spec
   */
  readonly spec: PermissionSetInlinePolicySpec;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicyProps(obj: PermissionSetInlinePolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PermissionSetInlinePolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PermissionSetInlinePolicySpec defines the desired state of PermissionSetInlinePolicy
 *
 * @schema PermissionSetInlinePolicySpec
 */
export interface PermissionSetInlinePolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema PermissionSetInlinePolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: PermissionSetInlinePolicySpecDeletionPolicy;

  /**
   * @schema PermissionSetInlinePolicySpec#forProvider
   */
  readonly forProvider: PermissionSetInlinePolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema PermissionSetInlinePolicySpec#initProvider
   */
  readonly initProvider?: PermissionSetInlinePolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema PermissionSetInlinePolicySpec#managementPolicies
   */
  readonly managementPolicies?: PermissionSetInlinePolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema PermissionSetInlinePolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: PermissionSetInlinePolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema PermissionSetInlinePolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: PermissionSetInlinePolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema PermissionSetInlinePolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: PermissionSetInlinePolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpec(obj: PermissionSetInlinePolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_PermissionSetInlinePolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_PermissionSetInlinePolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_PermissionSetInlinePolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_PermissionSetInlinePolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema PermissionSetInlinePolicySpecDeletionPolicy
 */
export enum PermissionSetInlinePolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema PermissionSetInlinePolicySpecForProvider
 */
export interface PermissionSetInlinePolicySpecForProvider {
  /**
   * The IAM inline policy to attach to a Permission Set.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#inlinePolicy
   */
  readonly inlinePolicy?: string;

  /**
   * The Amazon Resource Name (ARN) of the SSO Instance under which the operation will be executed.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#instanceArn
   */
  readonly instanceArn: string;

  /**
   * The Amazon Resource Name (ARN) of the Permission Set.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArn
   */
  readonly permissionSetArn?: string;

  /**
   * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArnRef
   */
  readonly permissionSetArnRef?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRef;

  /**
   * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#permissionSetArnSelector
   */
  readonly permissionSetArnSelector?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema PermissionSetInlinePolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProvider(obj: PermissionSetInlinePolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inlinePolicy': obj.inlinePolicy,
    'instanceArn': obj.instanceArn,
    'permissionSetArn': obj.permissionSetArn,
    'permissionSetArnRef': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRef(obj.permissionSetArnRef),
    'permissionSetArnSelector': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector(obj.permissionSetArnSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema PermissionSetInlinePolicySpecInitProvider
 */
export interface PermissionSetInlinePolicySpecInitProvider {
  /**
   * The IAM inline policy to attach to a Permission Set.
   *
   * @schema PermissionSetInlinePolicySpecInitProvider#inlinePolicy
   */
  readonly inlinePolicy?: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecInitProvider(obj: PermissionSetInlinePolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'inlinePolicy': obj.inlinePolicy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema PermissionSetInlinePolicySpecManagementPolicies
 */
export enum PermissionSetInlinePolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRef
 */
export interface PermissionSetInlinePolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderConfigRef(obj: PermissionSetInlinePolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsTo(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef
 */
export interface PermissionSetInlinePolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema PermissionSetInlinePolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecWriteConnectionSecretToRef(obj: PermissionSetInlinePolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRef(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a PermissionSet in ssoadmin to populate permissionSetArn.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy
 */
export interface PermissionSetInlinePolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecProviderConfigRefPolicy(obj: PermissionSetInlinePolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy
 */
export interface PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy(obj: PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve
 */
export enum PermissionSetInlinePolicySpecForProviderPermissionSetArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum PermissionSetInlinePolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

