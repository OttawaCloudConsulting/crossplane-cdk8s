// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Stack is the Schema for the Stacks API. Provides a CloudFormation Stack resource.
 *
 * @schema Stack
 */
export class Stack extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stack"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta1',
    kind: 'Stack',
  }

  /**
   * Renders a Kubernetes manifest for "Stack".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackProps): any {
    return {
      ...Stack.GVK,
      ...toJson_StackProps(props),
    };
  }

  /**
   * Defines a "Stack" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackProps) {
    super(scope, id, {
      ...Stack.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stack.GVK,
      ...toJson_StackProps(resolved),
    };
  }
}

/**
 * Stack is the Schema for the Stacks API. Provides a CloudFormation Stack resource.
 *
 * @schema Stack
 */
export interface StackProps {
  /**
   * @schema Stack#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSpec defines the desired state of Stack
   *
   * @schema Stack#spec
   */
  readonly spec: StackSpec;

}

/**
 * Converts an object of type 'StackProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackProps(obj: StackProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSpec defines the desired state of Stack
 *
 * @schema StackSpec
 */
export interface StackSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSpecDeletionPolicy;

  /**
   * @schema StackSpec#forProvider
   */
  readonly forProvider: StackSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema StackSpec#initProvider
   */
  readonly initProvider?: StackSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StackSpec#managementPolicies
   */
  readonly managementPolicies?: StackSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema StackSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema StackSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema StackSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpec(obj: StackSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSpecForProvider(obj.forProvider),
    'initProvider': toJson_StackSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StackSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StackSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSpecDeletionPolicy
 */
export enum StackSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSpecForProvider
 */
export interface StackSpecForProvider {
  /**
   * A list of capabilities.
   * Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, or CAPABILITY_AUTO_EXPAND
   *
   * @schema StackSpecForProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Set to true to disable rollback of the stack if stack creation failed.
   * Conflicts with on_failure.
   *
   * @schema StackSpecForProvider#disableRollback
   */
  readonly disableRollback?: boolean;

  /**
   * The ARN of an IAM role that AWS CloudFormation assumes to create the stack. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials.
   *
   * @schema StackSpecForProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecForProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: StackSpecForProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecForProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: StackSpecForProviderIamRoleArnSelector;

  /**
   * Stack name.
   *
   * @schema StackSpecForProvider#name
   */
  readonly name: string;

  /**
   * A list of SNS topic ARNs to publish stack related events.
   *
   * @schema StackSpecForProvider#notificationArns
   */
  readonly notificationArns?: string[];

  /**
   * Action to be taken if stack creation fails. This must be
   * one of: DO_NOTHING, ROLLBACK, or DELETE. Conflicts with disable_rollback.
   *
   * @schema StackSpecForProvider#onFailure
   */
  readonly onFailure?: string;

  /**
   * A map of Parameter structures that specify input parameters for the stack.
   *
   * @schema StackSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Structure containing the stack policy body.
   * Conflicts w/ policy_url.
   *
   * @schema StackSpecForProvider#policyBody
   */
  readonly policyBody?: string;

  /**
   * Location of a file containing the stack policy.
   * Conflicts w/ policy_body.
   *
   * @schema StackSpecForProvider#policyUrl
   */
  readonly policyUrl?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Structure containing the template body (max size: 51,200 bytes).
   *
   * @schema StackSpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * Location of a file containing the template body (max size: 460,800 bytes).
   *
   * @schema StackSpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

  /**
   * The amount of time that can pass before the stack status becomes CREATE_FAILED.
   *
   * @schema StackSpecForProvider#timeoutInMinutes
   */
  readonly timeoutInMinutes?: number;

}

/**
 * Converts an object of type 'StackSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProvider(obj: StackSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capabilities': obj.capabilities?.map(y => y),
    'disableRollback': obj.disableRollback,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_StackSpecForProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_StackSpecForProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'name': obj.name,
    'notificationArns': obj.notificationArns?.map(y => y),
    'onFailure': obj.onFailure,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policyBody': obj.policyBody,
    'policyUrl': obj.policyUrl,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
    'timeoutInMinutes': obj.timeoutInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema StackSpecInitProvider
 */
export interface StackSpecInitProvider {
  /**
   * A list of capabilities.
   * Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, or CAPABILITY_AUTO_EXPAND
   *
   * @schema StackSpecInitProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Set to true to disable rollback of the stack if stack creation failed.
   * Conflicts with on_failure.
   *
   * @schema StackSpecInitProvider#disableRollback
   */
  readonly disableRollback?: boolean;

  /**
   * The ARN of an IAM role that AWS CloudFormation assumes to create the stack. If you don't specify a value, AWS CloudFormation uses the role that was previously associated with the stack. If no role is available, AWS CloudFormation uses a temporary session that is generated from your user credentials.
   *
   * @schema StackSpecInitProvider#iamRoleArn
   */
  readonly iamRoleArn?: string;

  /**
   * Reference to a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecInitProvider#iamRoleArnRef
   */
  readonly iamRoleArnRef?: StackSpecInitProviderIamRoleArnRef;

  /**
   * Selector for a Role in iam to populate iamRoleArn.
   *
   * @schema StackSpecInitProvider#iamRoleArnSelector
   */
  readonly iamRoleArnSelector?: StackSpecInitProviderIamRoleArnSelector;

  /**
   * A list of SNS topic ARNs to publish stack related events.
   *
   * @schema StackSpecInitProvider#notificationArns
   */
  readonly notificationArns?: string[];

  /**
   * Action to be taken if stack creation fails. This must be
   * one of: DO_NOTHING, ROLLBACK, or DELETE. Conflicts with disable_rollback.
   *
   * @schema StackSpecInitProvider#onFailure
   */
  readonly onFailure?: string;

  /**
   * A map of Parameter structures that specify input parameters for the stack.
   *
   * @schema StackSpecInitProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Structure containing the stack policy body.
   * Conflicts w/ policy_url.
   *
   * @schema StackSpecInitProvider#policyBody
   */
  readonly policyBody?: string;

  /**
   * Location of a file containing the stack policy.
   * Conflicts w/ policy_body.
   *
   * @schema StackSpecInitProvider#policyUrl
   */
  readonly policyUrl?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Structure containing the template body (max size: 51,200 bytes).
   *
   * @schema StackSpecInitProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * Location of a file containing the template body (max size: 460,800 bytes).
   *
   * @schema StackSpecInitProvider#templateUrl
   */
  readonly templateUrl?: string;

  /**
   * The amount of time that can pass before the stack status becomes CREATE_FAILED.
   *
   * @schema StackSpecInitProvider#timeoutInMinutes
   */
  readonly timeoutInMinutes?: number;

}

/**
 * Converts an object of type 'StackSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecInitProvider(obj: StackSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'capabilities': obj.capabilities?.map(y => y),
    'disableRollback': obj.disableRollback,
    'iamRoleArn': obj.iamRoleArn,
    'iamRoleArnRef': toJson_StackSpecInitProviderIamRoleArnRef(obj.iamRoleArnRef),
    'iamRoleArnSelector': toJson_StackSpecInitProviderIamRoleArnSelector(obj.iamRoleArnSelector),
    'notificationArns': obj.notificationArns?.map(y => y),
    'onFailure': obj.onFailure,
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policyBody': obj.policyBody,
    'policyUrl': obj.policyUrl,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
    'timeoutInMinutes': obj.timeoutInMinutes,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema StackSpecManagementPolicies
 */
export enum StackSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema StackSpecProviderConfigRef
 */
export interface StackSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecProviderConfigRef#policy
   */
  readonly policy?: StackSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRef(obj: StackSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema StackSpecPublishConnectionDetailsTo
 */
export interface StackSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsTo(obj: StackSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema StackSpecWriteConnectionSecretToRef
 */
export interface StackSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecWriteConnectionSecretToRef(obj: StackSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecForProviderIamRoleArnRef
 */
export interface StackSpecForProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecForProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecForProviderIamRoleArnRef#policy
   */
  readonly policy?: StackSpecForProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnRef(obj: StackSpecForProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecForProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecForProviderIamRoleArnSelector
 */
export interface StackSpecForProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecForProviderIamRoleArnSelector#policy
   */
  readonly policy?: StackSpecForProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnSelector(obj: StackSpecForProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecForProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecInitProviderIamRoleArnRef
 */
export interface StackSpecInitProviderIamRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecInitProviderIamRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecInitProviderIamRoleArnRef#policy
   */
  readonly policy?: StackSpecInitProviderIamRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSpecInitProviderIamRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecInitProviderIamRoleArnRef(obj: StackSpecInitProviderIamRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecInitProviderIamRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate iamRoleArn.
 *
 * @schema StackSpecInitProviderIamRoleArnSelector
 */
export interface StackSpecInitProviderIamRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSpecInitProviderIamRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSpecInitProviderIamRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSpecInitProviderIamRoleArnSelector#policy
   */
  readonly policy?: StackSpecInitProviderIamRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSpecInitProviderIamRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecInitProviderIamRoleArnSelector(obj: StackSpecInitProviderIamRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSpecInitProviderIamRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecProviderConfigRefPolicy
 */
export interface StackSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecProviderConfigRefPolicy(obj: StackSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRef(obj: StackSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSpecPublishConnectionDetailsToMetadata
 */
export interface StackSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToMetadata(obj: StackSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicy
 */
export interface StackSpecForProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecForProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnRefPolicy(obj: StackSpecForProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicy
 */
export interface StackSpecForProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecForProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecForProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecForProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecForProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecForProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecForProviderIamRoleArnSelectorPolicy(obj: StackSpecForProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSpecInitProviderIamRoleArnRefPolicy
 */
export interface StackSpecInitProviderIamRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecInitProviderIamRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSpecInitProviderIamRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecInitProviderIamRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSpecInitProviderIamRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecInitProviderIamRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecInitProviderIamRoleArnRefPolicy(obj: StackSpecInitProviderIamRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSpecInitProviderIamRoleArnSelectorPolicy
 */
export interface StackSpecInitProviderIamRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecInitProviderIamRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSpecInitProviderIamRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecInitProviderIamRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSpecInitProviderIamRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecInitProviderIamRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecInitProviderIamRoleArnSelectorPolicy(obj: StackSpecInitProviderIamRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecProviderConfigRefPolicyResolution
 */
export enum StackSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecProviderConfigRefPolicyResolve
 */
export enum StackSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicyResolution
 */
export enum StackSpecForProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecForProviderIamRoleArnRefPolicyResolve
 */
export enum StackSpecForProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicyResolution
 */
export enum StackSpecForProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecForProviderIamRoleArnSelectorPolicyResolve
 */
export enum StackSpecForProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecInitProviderIamRoleArnRefPolicyResolution
 */
export enum StackSpecInitProviderIamRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecInitProviderIamRoleArnRefPolicyResolve
 */
export enum StackSpecInitProviderIamRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecInitProviderIamRoleArnSelectorPolicyResolution
 */
export enum StackSpecInitProviderIamRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecInitProviderIamRoleArnSelectorPolicyResolve
 */
export enum StackSpecInitProviderIamRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSet
 */
export class StackSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StackSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta1',
    kind: 'StackSet',
  }

  /**
   * Renders a Kubernetes manifest for "StackSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackSetProps): any {
    return {
      ...StackSet.GVK,
      ...toJson_StackSetProps(props),
    };
  }

  /**
   * Defines a "StackSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackSetProps) {
    super(scope, id, {
      ...StackSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StackSet.GVK,
      ...toJson_StackSetProps(resolved),
    };
  }
}

/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSet
 */
export interface StackSetProps {
  /**
   * @schema StackSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSetSpec defines the desired state of StackSet
   *
   * @schema StackSet#spec
   */
  readonly spec: StackSetSpec;

}

/**
 * Converts an object of type 'StackSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetProps(obj: StackSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSetSpec defines the desired state of StackSet
 *
 * @schema StackSetSpec
 */
export interface StackSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSetSpecDeletionPolicy;

  /**
   * @schema StackSetSpec#forProvider
   */
  readonly forProvider: StackSetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema StackSetSpec#initProvider
   */
  readonly initProvider?: StackSetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StackSetSpec#managementPolicies
   */
  readonly managementPolicies?: StackSetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema StackSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema StackSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema StackSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpec(obj: StackSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSetSpecForProvider(obj.forProvider),
    'initProvider': toJson_StackSetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StackSetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StackSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetSpecDeletionPolicy
 */
export enum StackSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSetSpecForProvider
 */
export interface StackSetSpecForProvider {
  /**
   * Amazon Resource Number (ARN) of the IAM Role in the administrator account. This must be defined when using the SELF_MANAGED permission model.
   *
   * @schema StackSetSpecForProvider#administrationRoleArn
   */
  readonly administrationRoleArn?: string;

  /**
   * Reference to a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecForProvider#administrationRoleArnRef
   */
  readonly administrationRoleArnRef?: StackSetSpecForProviderAdministrationRoleArnRef;

  /**
   * Selector for a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecForProvider#administrationRoleArnSelector
   */
  readonly administrationRoleArnSelector?: StackSetSpecForProviderAdministrationRoleArnSelector;

  /**
   * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
   *
   * @schema StackSetSpecForProvider#autoDeployment
   */
  readonly autoDeployment?: StackSetSpecForProviderAutoDeployment[];

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetSpecForProvider#callAs
   */
  readonly callAs?: string;

  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_AUTO_EXPAND.
   *
   * @schema StackSetSpecForProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Description of the StackSet.
   *
   * @schema StackSetSpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the IAM Role in all target accounts for StackSet operations. Defaults to AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   *
   * @default AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   * @schema StackSetSpecForProvider#executionRoleName
   */
  readonly executionRoleName?: string;

  /**
   * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
   *
   * @schema StackSetSpecForProvider#managedExecution
   */
  readonly managedExecution?: StackSetSpecForProviderManagedExecution[];

  /**
   * Preferences for how AWS CloudFormation performs a stack set update.
   *
   * @schema StackSetSpecForProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetSpecForProviderOperationPreferences[];

  /**
   * Key-value map of input parameters for the StackSet template. All template parameters, including those with a Default, must be configured or ignored with lifecycle configuration block ignore_changes argument. All NoEcho template parameters must be ignored with the lifecycle configuration block ignore_changes argument.
   *
   * @schema StackSetSpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Describes how the IAM roles required for your StackSet are created. Valid values: SELF_MANAGED (default), SERVICE_MANAGED.
   *
   * @schema StackSetSpecForProvider#permissionModel
   */
  readonly permissionModel?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSetSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSetSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * String containing the CloudFormation template body. Maximum size: 51,200 bytes. Conflicts with template_url.
   *
   * @schema StackSetSpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * String containing the location of a file containing the CloudFormation template body. The URL must point to a template that is located in an Amazon S3 bucket. Maximum location file size: 460,800 bytes. Conflicts with template_body.
   *
   * @schema StackSetSpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

}

/**
 * Converts an object of type 'StackSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProvider(obj: StackSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administrationRoleArn': obj.administrationRoleArn,
    'administrationRoleArnRef': toJson_StackSetSpecForProviderAdministrationRoleArnRef(obj.administrationRoleArnRef),
    'administrationRoleArnSelector': toJson_StackSetSpecForProviderAdministrationRoleArnSelector(obj.administrationRoleArnSelector),
    'autoDeployment': obj.autoDeployment?.map(y => toJson_StackSetSpecForProviderAutoDeployment(y)),
    'callAs': obj.callAs,
    'capabilities': obj.capabilities?.map(y => y),
    'description': obj.description,
    'executionRoleName': obj.executionRoleName,
    'managedExecution': obj.managedExecution?.map(y => toJson_StackSetSpecForProviderManagedExecution(y)),
    'operationPreferences': obj.operationPreferences?.map(y => toJson_StackSetSpecForProviderOperationPreferences(y)),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'permissionModel': obj.permissionModel,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema StackSetSpecInitProvider
 */
export interface StackSetSpecInitProvider {
  /**
   * Amazon Resource Number (ARN) of the IAM Role in the administrator account. This must be defined when using the SELF_MANAGED permission model.
   *
   * @schema StackSetSpecInitProvider#administrationRoleArn
   */
  readonly administrationRoleArn?: string;

  /**
   * Reference to a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecInitProvider#administrationRoleArnRef
   */
  readonly administrationRoleArnRef?: StackSetSpecInitProviderAdministrationRoleArnRef;

  /**
   * Selector for a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetSpecInitProvider#administrationRoleArnSelector
   */
  readonly administrationRoleArnSelector?: StackSetSpecInitProviderAdministrationRoleArnSelector;

  /**
   * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
   *
   * @schema StackSetSpecInitProvider#autoDeployment
   */
  readonly autoDeployment?: StackSetSpecInitProviderAutoDeployment[];

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetSpecInitProvider#callAs
   */
  readonly callAs?: string;

  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_AUTO_EXPAND.
   *
   * @schema StackSetSpecInitProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Description of the StackSet.
   *
   * @schema StackSetSpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Name of the IAM Role in all target accounts for StackSet operations. Defaults to AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   *
   * @default AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   * @schema StackSetSpecInitProvider#executionRoleName
   */
  readonly executionRoleName?: string;

  /**
   * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
   *
   * @schema StackSetSpecInitProvider#managedExecution
   */
  readonly managedExecution?: StackSetSpecInitProviderManagedExecution[];

  /**
   * Preferences for how AWS CloudFormation performs a stack set update.
   *
   * @schema StackSetSpecInitProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetSpecInitProviderOperationPreferences[];

  /**
   * Key-value map of input parameters for the StackSet template. All template parameters, including those with a Default, must be configured or ignored with lifecycle configuration block ignore_changes argument. All NoEcho template parameters must be ignored with the lifecycle configuration block ignore_changes argument.
   *
   * @schema StackSetSpecInitProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Describes how the IAM roles required for your StackSet are created. Valid values: SELF_MANAGED (default), SERVICE_MANAGED.
   *
   * @schema StackSetSpecInitProvider#permissionModel
   */
  readonly permissionModel?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSetSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * String containing the CloudFormation template body. Maximum size: 51,200 bytes. Conflicts with template_url.
   *
   * @schema StackSetSpecInitProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * String containing the location of a file containing the CloudFormation template body. The URL must point to a template that is located in an Amazon S3 bucket. Maximum location file size: 460,800 bytes. Conflicts with template_body.
   *
   * @schema StackSetSpecInitProvider#templateUrl
   */
  readonly templateUrl?: string;

}

/**
 * Converts an object of type 'StackSetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProvider(obj: StackSetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administrationRoleArn': obj.administrationRoleArn,
    'administrationRoleArnRef': toJson_StackSetSpecInitProviderAdministrationRoleArnRef(obj.administrationRoleArnRef),
    'administrationRoleArnSelector': toJson_StackSetSpecInitProviderAdministrationRoleArnSelector(obj.administrationRoleArnSelector),
    'autoDeployment': obj.autoDeployment?.map(y => toJson_StackSetSpecInitProviderAutoDeployment(y)),
    'callAs': obj.callAs,
    'capabilities': obj.capabilities?.map(y => y),
    'description': obj.description,
    'executionRoleName': obj.executionRoleName,
    'managedExecution': obj.managedExecution?.map(y => toJson_StackSetSpecInitProviderManagedExecution(y)),
    'operationPreferences': obj.operationPreferences?.map(y => toJson_StackSetSpecInitProviderOperationPreferences(y)),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'permissionModel': obj.permissionModel,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema StackSetSpecManagementPolicies
 */
export enum StackSetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema StackSetSpecProviderConfigRef
 */
export interface StackSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecProviderConfigRef#policy
   */
  readonly policy?: StackSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderConfigRef(obj: StackSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema StackSetSpecPublishConnectionDetailsTo
 */
export interface StackSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsTo(obj: StackSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema StackSetSpecWriteConnectionSecretToRef
 */
export interface StackSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecWriteConnectionSecretToRef(obj: StackSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRef
 */
export interface StackSetSpecForProviderAdministrationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRef#policy
   */
  readonly policy?: StackSetSpecForProviderAdministrationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnRef(obj: StackSetSpecForProviderAdministrationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecForProviderAdministrationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelector
 */
export interface StackSetSpecForProviderAdministrationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelector#policy
   */
  readonly policy?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnSelector(obj: StackSetSpecForProviderAdministrationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetSpecForProviderAdministrationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecForProviderAutoDeployment
 */
export interface StackSetSpecForProviderAutoDeployment {
  /**
   * Whether or not auto-deployment is enabled.
   *
   * @schema StackSetSpecForProviderAutoDeployment#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether or not to retain stacks when the account is removed.
   *
   * @schema StackSetSpecForProviderAutoDeployment#retainStacksOnAccountRemoval
   */
  readonly retainStacksOnAccountRemoval?: boolean;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAutoDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAutoDeployment(obj: StackSetSpecForProviderAutoDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retainStacksOnAccountRemoval': obj.retainStacksOnAccountRemoval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecForProviderManagedExecution
 */
export interface StackSetSpecForProviderManagedExecution {
  /**
   * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
   *
   * @default false.
   * @schema StackSetSpecForProviderManagedExecution#active
   */
  readonly active?: boolean;

}

/**
 * Converts an object of type 'StackSetSpecForProviderManagedExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderManagedExecution(obj: StackSetSpecForProviderManagedExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecForProviderOperationPreferences
 */
export interface StackSetSpecForProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecForProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecForProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
   *
   * @schema StackSetSpecForProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetSpecForProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetSpecForProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderOperationPreferences(obj: StackSetSpecForProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnRef
 */
export interface StackSetSpecInitProviderAdministrationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnRef#policy
   */
  readonly policy?: StackSetSpecInitProviderAdministrationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderAdministrationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderAdministrationRoleArnRef(obj: StackSetSpecInitProviderAdministrationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecInitProviderAdministrationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnSelector
 */
export interface StackSetSpecInitProviderAdministrationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnSelector#policy
   */
  readonly policy?: StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderAdministrationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderAdministrationRoleArnSelector(obj: StackSetSpecInitProviderAdministrationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecInitProviderAutoDeployment
 */
export interface StackSetSpecInitProviderAutoDeployment {
  /**
   * Whether or not auto-deployment is enabled.
   *
   * @schema StackSetSpecInitProviderAutoDeployment#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether or not to retain stacks when the account is removed.
   *
   * @schema StackSetSpecInitProviderAutoDeployment#retainStacksOnAccountRemoval
   */
  readonly retainStacksOnAccountRemoval?: boolean;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderAutoDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderAutoDeployment(obj: StackSetSpecInitProviderAutoDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retainStacksOnAccountRemoval': obj.retainStacksOnAccountRemoval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecInitProviderManagedExecution
 */
export interface StackSetSpecInitProviderManagedExecution {
  /**
   * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
   *
   * @default false.
   * @schema StackSetSpecInitProviderManagedExecution#active
   */
  readonly active?: boolean;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderManagedExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderManagedExecution(obj: StackSetSpecInitProviderManagedExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetSpecInitProviderOperationPreferences
 */
export interface StackSetSpecInitProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetSpecInitProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetSpecInitProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderOperationPreferences(obj: StackSetSpecInitProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecProviderConfigRefPolicy
 */
export interface StackSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecProviderConfigRefPolicy(obj: StackSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToConfigRef(obj: StackSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSetSpecPublishConnectionDetailsToMetadata
 */
export interface StackSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToMetadata(obj: StackSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy
 */
export interface StackSetSpecForProviderAdministrationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnRefPolicy(obj: StackSetSpecForProviderAdministrationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy
 */
export interface StackSetSpecForProviderAdministrationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecForProviderAdministrationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecForProviderAdministrationRoleArnSelectorPolicy(obj: StackSetSpecForProviderAdministrationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnRefPolicy
 */
export interface StackSetSpecInitProviderAdministrationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderAdministrationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderAdministrationRoleArnRefPolicy(obj: StackSetSpecInitProviderAdministrationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy
 */
export interface StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy(obj: StackSetSpecInitProviderAdministrationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecProviderConfigRefPolicyResolution
 */
export enum StackSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecProviderConfigRefPolicyResolve
 */
export enum StackSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution
 */
export enum StackSetSpecForProviderAdministrationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve
 */
export enum StackSetSpecForProviderAdministrationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution
 */
export enum StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve
 */
export enum StackSetSpecForProviderAdministrationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolution
 */
export enum StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolve
 */
export enum StackSetSpecInitProviderAdministrationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolution
 */
export enum StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolve
 */
export enum StackSetSpecInitProviderAdministrationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSetV1Beta2
 */
export class StackSetV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StackSetV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta2',
    kind: 'StackSet',
  }

  /**
   * Renders a Kubernetes manifest for "StackSetV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackSetV1Beta2Props): any {
    return {
      ...StackSetV1Beta2.GVK,
      ...toJson_StackSetV1Beta2Props(props),
    };
  }

  /**
   * Defines a "StackSetV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackSetV1Beta2Props) {
    super(scope, id, {
      ...StackSetV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StackSetV1Beta2.GVK,
      ...toJson_StackSetV1Beta2Props(resolved),
    };
  }
}

/**
 * StackSet is the Schema for the StackSets API. Manages a CloudFormation StackSet.
 *
 * @schema StackSetV1Beta2
 */
export interface StackSetV1Beta2Props {
  /**
   * @schema StackSetV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSetSpec defines the desired state of StackSet
   *
   * @schema StackSetV1Beta2#spec
   */
  readonly spec: StackSetV1Beta2Spec;

}

/**
 * Converts an object of type 'StackSetV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2Props(obj: StackSetV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSetV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSetSpec defines the desired state of StackSet
 *
 * @schema StackSetV1Beta2Spec
 */
export interface StackSetV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: StackSetV1Beta2SpecDeletionPolicy;

  /**
   * @schema StackSetV1Beta2Spec#forProvider
   */
  readonly forProvider: StackSetV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema StackSetV1Beta2Spec#initProvider
   */
  readonly initProvider?: StackSetV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StackSetV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: StackSetV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema StackSetV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: StackSetV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema StackSetV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSetV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema StackSetV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSetV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSetV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2Spec(obj: StackSetV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSetV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_StackSetV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StackSetV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StackSetV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSetV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetV1Beta2SpecDeletionPolicy
 */
export enum StackSetV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSetV1Beta2SpecForProvider
 */
export interface StackSetV1Beta2SpecForProvider {
  /**
   * Amazon Resource Number (ARN) of the IAM Role in the administrator account. This must be defined when using the SELF_MANAGED permission model.
   *
   * @schema StackSetV1Beta2SpecForProvider#administrationRoleArn
   */
  readonly administrationRoleArn?: string;

  /**
   * Reference to a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetV1Beta2SpecForProvider#administrationRoleArnRef
   */
  readonly administrationRoleArnRef?: StackSetV1Beta2SpecForProviderAdministrationRoleArnRef;

  /**
   * Selector for a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetV1Beta2SpecForProvider#administrationRoleArnSelector
   */
  readonly administrationRoleArnSelector?: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector;

  /**
   * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
   *
   * @schema StackSetV1Beta2SpecForProvider#autoDeployment
   */
  readonly autoDeployment?: StackSetV1Beta2SpecForProviderAutoDeployment;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetV1Beta2SpecForProvider#callAs
   */
  readonly callAs?: string;

  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_AUTO_EXPAND.
   *
   * @schema StackSetV1Beta2SpecForProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Description of the StackSet.
   *
   * @schema StackSetV1Beta2SpecForProvider#description
   */
  readonly description?: string;

  /**
   * Name of the IAM Role in all target accounts for StackSet operations. Defaults to AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   *
   * @default AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   * @schema StackSetV1Beta2SpecForProvider#executionRoleName
   */
  readonly executionRoleName?: string;

  /**
   * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
   *
   * @schema StackSetV1Beta2SpecForProvider#managedExecution
   */
  readonly managedExecution?: StackSetV1Beta2SpecForProviderManagedExecution;

  /**
   * Preferences for how AWS CloudFormation performs a stack set update.
   *
   * @schema StackSetV1Beta2SpecForProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetV1Beta2SpecForProviderOperationPreferences;

  /**
   * Key-value map of input parameters for the StackSet template. All template parameters, including those with a Default, must be configured or ignored with lifecycle configuration block ignore_changes argument. All NoEcho template parameters must be ignored with the lifecycle configuration block ignore_changes argument.
   *
   * @schema StackSetV1Beta2SpecForProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Describes how the IAM roles required for your StackSet are created. Valid values: SELF_MANAGED (default), SERVICE_MANAGED.
   *
   * @schema StackSetV1Beta2SpecForProvider#permissionModel
   */
  readonly permissionModel?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema StackSetV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSetV1Beta2SpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * String containing the CloudFormation template body. Maximum size: 51,200 bytes. Conflicts with template_url.
   *
   * @schema StackSetV1Beta2SpecForProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * String containing the location of a file containing the CloudFormation template body. The URL must point to a template that is located in an Amazon S3 bucket. Maximum location file size: 460,800 bytes. Conflicts with template_body.
   *
   * @schema StackSetV1Beta2SpecForProvider#templateUrl
   */
  readonly templateUrl?: string;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProvider(obj: StackSetV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administrationRoleArn': obj.administrationRoleArn,
    'administrationRoleArnRef': toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnRef(obj.administrationRoleArnRef),
    'administrationRoleArnSelector': toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector(obj.administrationRoleArnSelector),
    'autoDeployment': toJson_StackSetV1Beta2SpecForProviderAutoDeployment(obj.autoDeployment),
    'callAs': obj.callAs,
    'capabilities': obj.capabilities?.map(y => y),
    'description': obj.description,
    'executionRoleName': obj.executionRoleName,
    'managedExecution': toJson_StackSetV1Beta2SpecForProviderManagedExecution(obj.managedExecution),
    'operationPreferences': toJson_StackSetV1Beta2SpecForProviderOperationPreferences(obj.operationPreferences),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'permissionModel': obj.permissionModel,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema StackSetV1Beta2SpecInitProvider
 */
export interface StackSetV1Beta2SpecInitProvider {
  /**
   * Amazon Resource Number (ARN) of the IAM Role in the administrator account. This must be defined when using the SELF_MANAGED permission model.
   *
   * @schema StackSetV1Beta2SpecInitProvider#administrationRoleArn
   */
  readonly administrationRoleArn?: string;

  /**
   * Reference to a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetV1Beta2SpecInitProvider#administrationRoleArnRef
   */
  readonly administrationRoleArnRef?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef;

  /**
   * Selector for a Role in iam to populate administrationRoleArn.
   *
   * @schema StackSetV1Beta2SpecInitProvider#administrationRoleArnSelector
   */
  readonly administrationRoleArnSelector?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector;

  /**
   * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
   *
   * @schema StackSetV1Beta2SpecInitProvider#autoDeployment
   */
  readonly autoDeployment?: StackSetV1Beta2SpecInitProviderAutoDeployment;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetV1Beta2SpecInitProvider#callAs
   */
  readonly callAs?: string;

  /**
   * A list of capabilities. Valid values: CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_AUTO_EXPAND.
   *
   * @schema StackSetV1Beta2SpecInitProvider#capabilities
   */
  readonly capabilities?: string[];

  /**
   * Description of the StackSet.
   *
   * @schema StackSetV1Beta2SpecInitProvider#description
   */
  readonly description?: string;

  /**
   * Name of the IAM Role in all target accounts for StackSet operations. Defaults to AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   *
   * @default AWSCloudFormationStackSetExecutionRole when using the SELF_MANAGED permission model. This should not be defined when using the SERVICE_MANAGED permission model.
   * @schema StackSetV1Beta2SpecInitProvider#executionRoleName
   */
  readonly executionRoleName?: string;

  /**
   * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
   *
   * @schema StackSetV1Beta2SpecInitProvider#managedExecution
   */
  readonly managedExecution?: StackSetV1Beta2SpecInitProviderManagedExecution;

  /**
   * Preferences for how AWS CloudFormation performs a stack set update.
   *
   * @schema StackSetV1Beta2SpecInitProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetV1Beta2SpecInitProviderOperationPreferences;

  /**
   * Key-value map of input parameters for the StackSet template. All template parameters, including those with a Default, must be configured or ignored with lifecycle configuration block ignore_changes argument. All NoEcho template parameters must be ignored with the lifecycle configuration block ignore_changes argument.
   *
   * @schema StackSetV1Beta2SpecInitProvider#parameters
   */
  readonly parameters?: { [key: string]: string };

  /**
   * Describes how the IAM roles required for your StackSet are created. Valid values: SELF_MANAGED (default), SERVICE_MANAGED.
   *
   * @schema StackSetV1Beta2SpecInitProvider#permissionModel
   */
  readonly permissionModel?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema StackSetV1Beta2SpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * String containing the CloudFormation template body. Maximum size: 51,200 bytes. Conflicts with template_url.
   *
   * @schema StackSetV1Beta2SpecInitProvider#templateBody
   */
  readonly templateBody?: string;

  /**
   * String containing the location of a file containing the CloudFormation template body. The URL must point to a template that is located in an Amazon S3 bucket. Maximum location file size: 460,800 bytes. Conflicts with template_body.
   *
   * @schema StackSetV1Beta2SpecInitProvider#templateUrl
   */
  readonly templateUrl?: string;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProvider(obj: StackSetV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'administrationRoleArn': obj.administrationRoleArn,
    'administrationRoleArnRef': toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef(obj.administrationRoleArnRef),
    'administrationRoleArnSelector': toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector(obj.administrationRoleArnSelector),
    'autoDeployment': toJson_StackSetV1Beta2SpecInitProviderAutoDeployment(obj.autoDeployment),
    'callAs': obj.callAs,
    'capabilities': obj.capabilities?.map(y => y),
    'description': obj.description,
    'executionRoleName': obj.executionRoleName,
    'managedExecution': toJson_StackSetV1Beta2SpecInitProviderManagedExecution(obj.managedExecution),
    'operationPreferences': toJson_StackSetV1Beta2SpecInitProviderOperationPreferences(obj.operationPreferences),
    'parameters': ((obj.parameters) === undefined) ? undefined : (Object.entries(obj.parameters).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'permissionModel': obj.permissionModel,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'templateBody': obj.templateBody,
    'templateUrl': obj.templateUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema StackSetV1Beta2SpecManagementPolicies
 */
export enum StackSetV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema StackSetV1Beta2SpecProviderConfigRef
 */
export interface StackSetV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: StackSetV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecProviderConfigRef(obj: StackSetV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsTo
 */
export interface StackSetV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSetV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecPublishConnectionDetailsTo(obj: StackSetV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSetV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema StackSetV1Beta2SpecWriteConnectionSecretToRef
 */
export interface StackSetV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSetV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSetV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecWriteConnectionSecretToRef(obj: StackSetV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRef
 */
export interface StackSetV1Beta2SpecForProviderAdministrationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRef#policy
   */
  readonly policy?: StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderAdministrationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnRef(obj: StackSetV1Beta2SpecForProviderAdministrationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector
 */
export interface StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector#policy
   */
  readonly policy?: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector(obj: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
 *
 * @schema StackSetV1Beta2SpecForProviderAutoDeployment
 */
export interface StackSetV1Beta2SpecForProviderAutoDeployment {
  /**
   * Whether or not auto-deployment is enabled.
   *
   * @schema StackSetV1Beta2SpecForProviderAutoDeployment#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether or not to retain stacks when the account is removed.
   *
   * @schema StackSetV1Beta2SpecForProviderAutoDeployment#retainStacksOnAccountRemoval
   */
  readonly retainStacksOnAccountRemoval?: boolean;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderAutoDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderAutoDeployment(obj: StackSetV1Beta2SpecForProviderAutoDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retainStacksOnAccountRemoval': obj.retainStacksOnAccountRemoval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
 *
 * @schema StackSetV1Beta2SpecForProviderManagedExecution
 */
export interface StackSetV1Beta2SpecForProviderManagedExecution {
  /**
   * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
   *
   * @default false.
   * @schema StackSetV1Beta2SpecForProviderManagedExecution#active
   */
  readonly active?: boolean;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderManagedExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderManagedExecution(obj: StackSetV1Beta2SpecForProviderManagedExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preferences for how AWS CloudFormation performs a stack set update.
 *
 * @schema StackSetV1Beta2SpecForProviderOperationPreferences
 */
export interface StackSetV1Beta2SpecForProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetV1Beta2SpecForProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderOperationPreferences(obj: StackSetV1Beta2SpecForProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef
 */
export interface StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef#policy
   */
  readonly policy?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef(obj: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Role in iam to populate administrationRoleArn.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector
 */
export interface StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector#policy
   */
  readonly policy?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector(obj: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration block containing the auto-deployment model for your StackSet. This can only be defined when using the SERVICE_MANAGED permission model.
 *
 * @schema StackSetV1Beta2SpecInitProviderAutoDeployment
 */
export interface StackSetV1Beta2SpecInitProviderAutoDeployment {
  /**
   * Whether or not auto-deployment is enabled.
   *
   * @schema StackSetV1Beta2SpecInitProviderAutoDeployment#enabled
   */
  readonly enabled?: boolean;

  /**
   * Whether or not to retain stacks when the account is removed.
   *
   * @schema StackSetV1Beta2SpecInitProviderAutoDeployment#retainStacksOnAccountRemoval
   */
  readonly retainStacksOnAccountRemoval?: boolean;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderAutoDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderAutoDeployment(obj: StackSetV1Beta2SpecInitProviderAutoDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
    'retainStacksOnAccountRemoval': obj.retainStacksOnAccountRemoval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration block to allow StackSets to perform non-conflicting operations concurrently and queues conflicting operations.
 *
 * @schema StackSetV1Beta2SpecInitProviderManagedExecution
 */
export interface StackSetV1Beta2SpecInitProviderManagedExecution {
  /**
   * When set to true, StackSets performs non-conflicting operations concurrently and queues conflicting operations. After conflicting operations finish, StackSets starts queued operations in request order. Default is false.
   *
   * @default false.
   * @schema StackSetV1Beta2SpecInitProviderManagedExecution#active
   */
  readonly active?: boolean;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderManagedExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderManagedExecution(obj: StackSetV1Beta2SpecInitProviderManagedExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'active': obj.active,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preferences for how AWS CloudFormation performs a stack set update.
 *
 * @schema StackSetV1Beta2SpecInitProviderOperationPreferences
 */
export interface StackSetV1Beta2SpecInitProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetV1Beta2SpecInitProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderOperationPreferences(obj: StackSetV1Beta2SpecInitProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetV1Beta2SpecProviderConfigRefPolicy
 */
export interface StackSetV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecProviderConfigRefPolicy(obj: StackSetV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface StackSetV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecPublishConnectionDetailsToMetadata(obj: StackSetV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy
 */
export interface StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy(obj: StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy
 */
export interface StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy(obj: StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy
 */
export interface StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy(obj: StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy
 */
export interface StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy(obj: StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum StackSetV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum StackSetV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolution
 */
export enum StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolve
 */
export enum StackSetV1Beta2SpecForProviderAdministrationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolution
 */
export enum StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolve
 */
export enum StackSetV1Beta2SpecForProviderAdministrationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolution
 */
export enum StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolve
 */
export enum StackSetV1Beta2SpecInitProviderAdministrationRoleArnRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolution
 */
export enum StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolve
 */
export enum StackSetV1Beta2SpecInitProviderAdministrationRoleArnSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSetV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StackSetInstance is the Schema for the StackSetInstances API. Manages a CloudFormation StackSet Instance.
 *
 * @schema StackSetInstance
 */
export class StackSetInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StackSetInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta1',
    kind: 'StackSetInstance',
  }

  /**
   * Renders a Kubernetes manifest for "StackSetInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackSetInstanceProps): any {
    return {
      ...StackSetInstance.GVK,
      ...toJson_StackSetInstanceProps(props),
    };
  }

  /**
   * Defines a "StackSetInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackSetInstanceProps) {
    super(scope, id, {
      ...StackSetInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StackSetInstance.GVK,
      ...toJson_StackSetInstanceProps(resolved),
    };
  }
}

/**
 * StackSetInstance is the Schema for the StackSetInstances API. Manages a CloudFormation StackSet Instance.
 *
 * @schema StackSetInstance
 */
export interface StackSetInstanceProps {
  /**
   * @schema StackSetInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSetInstanceSpec defines the desired state of StackSetInstance
   *
   * @schema StackSetInstance#spec
   */
  readonly spec: StackSetInstanceSpec;

}

/**
 * Converts an object of type 'StackSetInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceProps(obj: StackSetInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSetInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSetInstanceSpec defines the desired state of StackSetInstance
 *
 * @schema StackSetInstanceSpec
 */
export interface StackSetInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: StackSetInstanceSpecDeletionPolicy;

  /**
   * @schema StackSetInstanceSpec#forProvider
   */
  readonly forProvider: StackSetInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema StackSetInstanceSpec#initProvider
   */
  readonly initProvider?: StackSetInstanceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StackSetInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: StackSetInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema StackSetInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: StackSetInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema StackSetInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSetInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema StackSetInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSetInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSetInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpec(obj: StackSetInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSetInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_StackSetInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StackSetInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StackSetInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSetInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetInstanceSpecDeletionPolicy
 */
export enum StackSetInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSetInstanceSpecForProvider
 */
export interface StackSetInstanceSpecForProvider {
  /**
   * Target AWS Account ID to create a Stack based on the StackSet. Defaults to current account.
   *
   * @default current account.
   * @schema StackSetInstanceSpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetInstanceSpecForProvider#callAs
   */
  readonly callAs?: string;

  /**
   * The AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
   *
   * @schema StackSetInstanceSpecForProvider#deploymentTargets
   */
  readonly deploymentTargets?: StackSetInstanceSpecForProviderDeploymentTargets[];

  /**
   * Preferences for how AWS CloudFormation performs a stack set operation.
   *
   * @schema StackSetInstanceSpecForProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetInstanceSpecForProviderOperationPreferences[];

  /**
   * Key-value map of input parameters to override from the StackSet for this Instance.
   *
   * @schema StackSetInstanceSpecForProvider#parameterOverrides
   */
  readonly parameterOverrides?: { [key: string]: string };

  /**
   * Target AWS Region to create a Stack based on the StackSet. Defaults to current region.
   * Region is the region you'd like your resource to be created in.
   *
   * @default current region.
   * @schema StackSetInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * You cannot reassociate a retained Stack or add an existing, saved Stack to a new StackSet. Defaults to false.
   *
   * @default false.
   * @schema StackSetInstanceSpecForProvider#retainStack
   */
  readonly retainStack?: boolean;

  /**
   * Name of the StackSet.
   *
   * @schema StackSetInstanceSpecForProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Reference to a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceSpecForProvider#stackSetNameRef
   */
  readonly stackSetNameRef?: StackSetInstanceSpecForProviderStackSetNameRef;

  /**
   * Selector for a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceSpecForProvider#stackSetNameSelector
   */
  readonly stackSetNameSelector?: StackSetInstanceSpecForProviderStackSetNameSelector;

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProvider(obj: StackSetInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'callAs': obj.callAs,
    'deploymentTargets': obj.deploymentTargets?.map(y => toJson_StackSetInstanceSpecForProviderDeploymentTargets(y)),
    'operationPreferences': obj.operationPreferences?.map(y => toJson_StackSetInstanceSpecForProviderOperationPreferences(y)),
    'parameterOverrides': ((obj.parameterOverrides) === undefined) ? undefined : (Object.entries(obj.parameterOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'retainStack': obj.retainStack,
    'stackSetName': obj.stackSetName,
    'stackSetNameRef': toJson_StackSetInstanceSpecForProviderStackSetNameRef(obj.stackSetNameRef),
    'stackSetNameSelector': toJson_StackSetInstanceSpecForProviderStackSetNameSelector(obj.stackSetNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema StackSetInstanceSpecInitProvider
 */
export interface StackSetInstanceSpecInitProvider {
  /**
   * Target AWS Account ID to create a Stack based on the StackSet. Defaults to current account.
   *
   * @default current account.
   * @schema StackSetInstanceSpecInitProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetInstanceSpecInitProvider#callAs
   */
  readonly callAs?: string;

  /**
   * The AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
   *
   * @schema StackSetInstanceSpecInitProvider#deploymentTargets
   */
  readonly deploymentTargets?: StackSetInstanceSpecInitProviderDeploymentTargets[];

  /**
   * Preferences for how AWS CloudFormation performs a stack set operation.
   *
   * @schema StackSetInstanceSpecInitProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetInstanceSpecInitProviderOperationPreferences[];

  /**
   * Key-value map of input parameters to override from the StackSet for this Instance.
   *
   * @schema StackSetInstanceSpecInitProvider#parameterOverrides
   */
  readonly parameterOverrides?: { [key: string]: string };

  /**
   * You cannot reassociate a retained Stack or add an existing, saved Stack to a new StackSet. Defaults to false.
   *
   * @default false.
   * @schema StackSetInstanceSpecInitProvider#retainStack
   */
  readonly retainStack?: boolean;

  /**
   * Name of the StackSet.
   *
   * @schema StackSetInstanceSpecInitProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Reference to a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceSpecInitProvider#stackSetNameRef
   */
  readonly stackSetNameRef?: StackSetInstanceSpecInitProviderStackSetNameRef;

  /**
   * Selector for a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceSpecInitProvider#stackSetNameSelector
   */
  readonly stackSetNameSelector?: StackSetInstanceSpecInitProviderStackSetNameSelector;

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProvider(obj: StackSetInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'callAs': obj.callAs,
    'deploymentTargets': obj.deploymentTargets?.map(y => toJson_StackSetInstanceSpecInitProviderDeploymentTargets(y)),
    'operationPreferences': obj.operationPreferences?.map(y => toJson_StackSetInstanceSpecInitProviderOperationPreferences(y)),
    'parameterOverrides': ((obj.parameterOverrides) === undefined) ? undefined : (Object.entries(obj.parameterOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'retainStack': obj.retainStack,
    'stackSetName': obj.stackSetName,
    'stackSetNameRef': toJson_StackSetInstanceSpecInitProviderStackSetNameRef(obj.stackSetNameRef),
    'stackSetNameSelector': toJson_StackSetInstanceSpecInitProviderStackSetNameSelector(obj.stackSetNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema StackSetInstanceSpecManagementPolicies
 */
export enum StackSetInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema StackSetInstanceSpecProviderConfigRef
 */
export interface StackSetInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: StackSetInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecProviderConfigRef(obj: StackSetInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsTo
 */
export interface StackSetInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSetInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSetInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSetInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecPublishConnectionDetailsTo(obj: StackSetInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSetInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSetInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema StackSetInstanceSpecWriteConnectionSecretToRef
 */
export interface StackSetInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSetInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSetInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSetInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecWriteConnectionSecretToRef(obj: StackSetInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetInstanceSpecForProviderDeploymentTargets
 */
export interface StackSetInstanceSpecForProviderDeploymentTargets {
  /**
   * Limit deployment targets to individual accounts or include additional accounts with provided OUs. Valid values: INTERSECTION, DIFFERENCE, UNION, NONE.
   *
   * @schema StackSetInstanceSpecForProviderDeploymentTargets#accountFilterType
   */
  readonly accountFilterType?: string;

  /**
   * List of accounts to deploy stack set updates.
   *
   * @schema StackSetInstanceSpecForProviderDeploymentTargets#accounts
   */
  readonly accounts?: string[];

  /**
   * S3 URL of the file containing the list of accounts.
   *
   * @schema StackSetInstanceSpecForProviderDeploymentTargets#accountsUrl
   */
  readonly accountsUrl?: string;

  /**
   * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
   *
   * @schema StackSetInstanceSpecForProviderDeploymentTargets#organizationalUnitIds
   */
  readonly organizationalUnitIds?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderDeploymentTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderDeploymentTargets(obj: StackSetInstanceSpecForProviderDeploymentTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountFilterType': obj.accountFilterType,
    'accounts': obj.accounts?.map(y => y),
    'accountsUrl': obj.accountsUrl,
    'organizationalUnitIds': obj.organizationalUnitIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetInstanceSpecForProviderOperationPreferences
 */
export interface StackSetInstanceSpecForProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are SEQUENTIAL and PARALLEL.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetInstanceSpecForProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderOperationPreferences(obj: StackSetInstanceSpecForProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameRef
 */
export interface StackSetInstanceSpecForProviderStackSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameRef#policy
   */
  readonly policy?: StackSetInstanceSpecForProviderStackSetNameRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderStackSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderStackSetNameRef(obj: StackSetInstanceSpecForProviderStackSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceSpecForProviderStackSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameSelector
 */
export interface StackSetInstanceSpecForProviderStackSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameSelector#policy
   */
  readonly policy?: StackSetInstanceSpecForProviderStackSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderStackSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderStackSetNameSelector(obj: StackSetInstanceSpecForProviderStackSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetInstanceSpecForProviderStackSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetInstanceSpecInitProviderDeploymentTargets
 */
export interface StackSetInstanceSpecInitProviderDeploymentTargets {
  /**
   * Limit deployment targets to individual accounts or include additional accounts with provided OUs. Valid values: INTERSECTION, DIFFERENCE, UNION, NONE.
   *
   * @schema StackSetInstanceSpecInitProviderDeploymentTargets#accountFilterType
   */
  readonly accountFilterType?: string;

  /**
   * List of accounts to deploy stack set updates.
   *
   * @schema StackSetInstanceSpecInitProviderDeploymentTargets#accounts
   */
  readonly accounts?: string[];

  /**
   * S3 URL of the file containing the list of accounts.
   *
   * @schema StackSetInstanceSpecInitProviderDeploymentTargets#accountsUrl
   */
  readonly accountsUrl?: string;

  /**
   * The organization root ID or organizational unit (OU) IDs to which StackSets deploys.
   *
   * @schema StackSetInstanceSpecInitProviderDeploymentTargets#organizationalUnitIds
   */
  readonly organizationalUnitIds?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderDeploymentTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderDeploymentTargets(obj: StackSetInstanceSpecInitProviderDeploymentTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountFilterType': obj.accountFilterType,
    'accounts': obj.accounts?.map(y => y),
    'accountsUrl': obj.accountsUrl,
    'organizationalUnitIds': obj.organizationalUnitIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema StackSetInstanceSpecInitProviderOperationPreferences
 */
export interface StackSetInstanceSpecInitProviderOperationPreferences {
  /**
   * The number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * The percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * The maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * The maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * The concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are SEQUENTIAL and PARALLEL.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * The order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetInstanceSpecInitProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderOperationPreferences(obj: StackSetInstanceSpecInitProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameRef
 */
export interface StackSetInstanceSpecInitProviderStackSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameRef#policy
   */
  readonly policy?: StackSetInstanceSpecInitProviderStackSetNameRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderStackSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderStackSetNameRef(obj: StackSetInstanceSpecInitProviderStackSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceSpecInitProviderStackSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameSelector
 */
export interface StackSetInstanceSpecInitProviderStackSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameSelector#policy
   */
  readonly policy?: StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderStackSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderStackSetNameSelector(obj: StackSetInstanceSpecInitProviderStackSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceSpecProviderConfigRefPolicy
 */
export interface StackSetInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecProviderConfigRefPolicy(obj: StackSetInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface StackSetInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecPublishConnectionDetailsToConfigRef(obj: StackSetInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface StackSetInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSetInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecPublishConnectionDetailsToMetadata(obj: StackSetInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameRefPolicy
 */
export interface StackSetInstanceSpecForProviderStackSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecForProviderStackSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecForProviderStackSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderStackSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderStackSetNameRefPolicy(obj: StackSetInstanceSpecForProviderStackSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameSelectorPolicy
 */
export interface StackSetInstanceSpecForProviderStackSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameSelectorPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecForProviderStackSetNameSelectorPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecForProviderStackSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecForProviderStackSetNameSelectorPolicy(obj: StackSetInstanceSpecForProviderStackSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameRefPolicy
 */
export interface StackSetInstanceSpecInitProviderStackSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderStackSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderStackSetNameRefPolicy(obj: StackSetInstanceSpecInitProviderStackSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy
 */
export interface StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy(obj: StackSetInstanceSpecInitProviderStackSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecProviderConfigRefPolicyResolution
 */
export enum StackSetInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecProviderConfigRefPolicyResolve
 */
export enum StackSetInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameRefPolicyResolution
 */
export enum StackSetInstanceSpecForProviderStackSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameRefPolicyResolve
 */
export enum StackSetInstanceSpecForProviderStackSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolution
 */
export enum StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolve
 */
export enum StackSetInstanceSpecForProviderStackSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolution
 */
export enum StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolve
 */
export enum StackSetInstanceSpecInitProviderStackSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolution
 */
export enum StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolve
 */
export enum StackSetInstanceSpecInitProviderStackSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSetInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * StackSetInstance is the Schema for the StackSetInstances API. Manages a CloudFormation StackSet Instance.
 *
 * @schema StackSetInstanceV1Beta2
 */
export class StackSetInstanceV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "StackSetInstanceV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cloudformation.aws.upbound.io/v1beta2',
    kind: 'StackSetInstance',
  }

  /**
   * Renders a Kubernetes manifest for "StackSetInstanceV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StackSetInstanceV1Beta2Props): any {
    return {
      ...StackSetInstanceV1Beta2.GVK,
      ...toJson_StackSetInstanceV1Beta2Props(props),
    };
  }

  /**
   * Defines a "StackSetInstanceV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StackSetInstanceV1Beta2Props) {
    super(scope, id, {
      ...StackSetInstanceV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...StackSetInstanceV1Beta2.GVK,
      ...toJson_StackSetInstanceV1Beta2Props(resolved),
    };
  }
}

/**
 * StackSetInstance is the Schema for the StackSetInstances API. Manages a CloudFormation StackSet Instance.
 *
 * @schema StackSetInstanceV1Beta2
 */
export interface StackSetInstanceV1Beta2Props {
  /**
   * @schema StackSetInstanceV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * StackSetInstanceSpec defines the desired state of StackSetInstance
   *
   * @schema StackSetInstanceV1Beta2#spec
   */
  readonly spec: StackSetInstanceV1Beta2Spec;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2Props(obj: StackSetInstanceV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StackSetInstanceV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * StackSetInstanceSpec defines the desired state of StackSetInstance
 *
 * @schema StackSetInstanceV1Beta2Spec
 */
export interface StackSetInstanceV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema StackSetInstanceV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: StackSetInstanceV1Beta2SpecDeletionPolicy;

  /**
   * @schema StackSetInstanceV1Beta2Spec#forProvider
   */
  readonly forProvider: StackSetInstanceV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema StackSetInstanceV1Beta2Spec#initProvider
   */
  readonly initProvider?: StackSetInstanceV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema StackSetInstanceV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: StackSetInstanceV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema StackSetInstanceV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: StackSetInstanceV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema StackSetInstanceV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema StackSetInstanceV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2Spec(obj: StackSetInstanceV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_StackSetInstanceV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_StackSetInstanceV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_StackSetInstanceV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema StackSetInstanceV1Beta2SpecDeletionPolicy
 */
export enum StackSetInstanceV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema StackSetInstanceV1Beta2SpecForProvider
 */
export interface StackSetInstanceV1Beta2SpecForProvider {
  /**
   * Target AWS Account ID to create a Stack based on the StackSet. Defaults to current account.
   *
   * @default current account.
   * @schema StackSetInstanceV1Beta2SpecForProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#callAs
   */
  readonly callAs?: string;

  /**
   * AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#deploymentTargets
   */
  readonly deploymentTargets?: StackSetInstanceV1Beta2SpecForProviderDeploymentTargets;

  /**
   * Preferences for how AWS CloudFormation performs a stack set operation.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetInstanceV1Beta2SpecForProviderOperationPreferences;

  /**
   * Key-value map of input parameters to override from the StackSet for this Instance.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#parameterOverrides
   */
  readonly parameterOverrides?: { [key: string]: string };

  /**
   * Target AWS Region to create a Stack based on the StackSet. Defaults to current region.
   * Region is the region you'd like your resource to be created in.
   *
   * @default current region.
   * @schema StackSetInstanceV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * You cannot reassociate a retained Stack or add an existing, saved Stack to a new StackSet. Defaults to false.
   *
   * @default false.
   * @schema StackSetInstanceV1Beta2SpecForProvider#retainStack
   */
  readonly retainStack?: boolean;

  /**
   * Name of the StackSet.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Reference to a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#stackSetNameRef
   */
  readonly stackSetNameRef?: StackSetInstanceV1Beta2SpecForProviderStackSetNameRef;

  /**
   * Selector for a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceV1Beta2SpecForProvider#stackSetNameSelector
   */
  readonly stackSetNameSelector?: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProvider(obj: StackSetInstanceV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'callAs': obj.callAs,
    'deploymentTargets': toJson_StackSetInstanceV1Beta2SpecForProviderDeploymentTargets(obj.deploymentTargets),
    'operationPreferences': toJson_StackSetInstanceV1Beta2SpecForProviderOperationPreferences(obj.operationPreferences),
    'parameterOverrides': ((obj.parameterOverrides) === undefined) ? undefined : (Object.entries(obj.parameterOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'region': obj.region,
    'retainStack': obj.retainStack,
    'stackSetName': obj.stackSetName,
    'stackSetNameRef': toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameRef(obj.stackSetNameRef),
    'stackSetNameSelector': toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector(obj.stackSetNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProvider
 */
export interface StackSetInstanceV1Beta2SpecInitProvider {
  /**
   * Target AWS Account ID to create a Stack based on the StackSet. Defaults to current account.
   *
   * @default current account.
   * @schema StackSetInstanceV1Beta2SpecInitProvider#accountId
   */
  readonly accountId?: string;

  /**
   * Specifies whether you are acting as an account administrator in the organization's management account or as a delegated administrator in a member account. Valid values: SELF (default), DELEGATED_ADMIN.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#callAs
   */
  readonly callAs?: string;

  /**
   * AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#deploymentTargets
   */
  readonly deploymentTargets?: StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets;

  /**
   * Preferences for how AWS CloudFormation performs a stack set operation.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#operationPreferences
   */
  readonly operationPreferences?: StackSetInstanceV1Beta2SpecInitProviderOperationPreferences;

  /**
   * Key-value map of input parameters to override from the StackSet for this Instance.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#parameterOverrides
   */
  readonly parameterOverrides?: { [key: string]: string };

  /**
   * You cannot reassociate a retained Stack or add an existing, saved Stack to a new StackSet. Defaults to false.
   *
   * @default false.
   * @schema StackSetInstanceV1Beta2SpecInitProvider#retainStack
   */
  readonly retainStack?: boolean;

  /**
   * Name of the StackSet.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#stackSetName
   */
  readonly stackSetName?: string;

  /**
   * Reference to a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#stackSetNameRef
   */
  readonly stackSetNameRef?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef;

  /**
   * Selector for a StackSet in cloudformation to populate stackSetName.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProvider#stackSetNameSelector
   */
  readonly stackSetNameSelector?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProvider(obj: StackSetInstanceV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountId': obj.accountId,
    'callAs': obj.callAs,
    'deploymentTargets': toJson_StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets(obj.deploymentTargets),
    'operationPreferences': toJson_StackSetInstanceV1Beta2SpecInitProviderOperationPreferences(obj.operationPreferences),
    'parameterOverrides': ((obj.parameterOverrides) === undefined) ? undefined : (Object.entries(obj.parameterOverrides).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'retainStack': obj.retainStack,
    'stackSetName': obj.stackSetName,
    'stackSetNameRef': toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef(obj.stackSetNameRef),
    'stackSetNameSelector': toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector(obj.stackSetNameSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema StackSetInstanceV1Beta2SpecManagementPolicies
 */
export enum StackSetInstanceV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema StackSetInstanceV1Beta2SpecProviderConfigRef
 */
export interface StackSetInstanceV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecProviderConfigRef(obj: StackSetInstanceV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo
 */
export interface StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo(obj: StackSetInstanceV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef
 */
export interface StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef(obj: StackSetInstanceV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderDeploymentTargets
 */
export interface StackSetInstanceV1Beta2SpecForProviderDeploymentTargets {
  /**
   * Limit deployment targets to individual accounts or include additional accounts with provided OUs. Valid values: INTERSECTION, DIFFERENCE, UNION, NONE.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderDeploymentTargets#accountFilterType
   */
  readonly accountFilterType?: string;

  /**
   * List of accounts to deploy stack set updates.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderDeploymentTargets#accounts
   */
  readonly accounts?: string[];

  /**
   * S3 URL of the file containing the list of accounts.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderDeploymentTargets#accountsUrl
   */
  readonly accountsUrl?: string;

  /**
   * Organization root ID or organizational unit (OU) IDs to which StackSets deploys.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderDeploymentTargets#organizationalUnitIds
   */
  readonly organizationalUnitIds?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderDeploymentTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderDeploymentTargets(obj: StackSetInstanceV1Beta2SpecForProviderDeploymentTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountFilterType': obj.accountFilterType,
    'accounts': obj.accounts?.map(y => y),
    'accountsUrl': obj.accountsUrl,
    'organizationalUnitIds': obj.organizationalUnitIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preferences for how AWS CloudFormation performs a stack set operation.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences
 */
export interface StackSetInstanceV1Beta2SpecForProviderOperationPreferences {
  /**
   * Number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * Percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * Maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * Maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * Concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are SEQUENTIAL and PARALLEL.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * Order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderOperationPreferences(obj: StackSetInstanceV1Beta2SpecForProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRef
 */
export interface StackSetInstanceV1Beta2SpecForProviderStackSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRef#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderStackSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameRef(obj: StackSetInstanceV1Beta2SpecForProviderStackSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector
 */
export interface StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector(obj: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWS Organizations accounts to which StackSets deploys. StackSets doesn't deploy stack instances to the organization management account, even if the organization management account is in your organization or in an OU in your organization. Drift detection is not possible for this argument. See deployment_targets below.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets
 */
export interface StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets {
  /**
   * Limit deployment targets to individual accounts or include additional accounts with provided OUs. Valid values: INTERSECTION, DIFFERENCE, UNION, NONE.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets#accountFilterType
   */
  readonly accountFilterType?: string;

  /**
   * List of accounts to deploy stack set updates.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets#accounts
   */
  readonly accounts?: string[];

  /**
   * S3 URL of the file containing the list of accounts.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets#accountsUrl
   */
  readonly accountsUrl?: string;

  /**
   * Organization root ID or organizational unit (OU) IDs to which StackSets deploys.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets#organizationalUnitIds
   */
  readonly organizationalUnitIds?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets(obj: StackSetInstanceV1Beta2SpecInitProviderDeploymentTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accountFilterType': obj.accountFilterType,
    'accounts': obj.accounts?.map(y => y),
    'accountsUrl': obj.accountsUrl,
    'organizationalUnitIds': obj.organizationalUnitIds?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Preferences for how AWS CloudFormation performs a stack set operation.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences
 */
export interface StackSetInstanceV1Beta2SpecInitProviderOperationPreferences {
  /**
   * Number of accounts, per Region, for which this operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#failureToleranceCount
   */
  readonly failureToleranceCount?: number;

  /**
   * Percentage of accounts, per Region, for which this stack operation can fail before AWS CloudFormation stops the operation in that Region.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#failureTolerancePercentage
   */
  readonly failureTolerancePercentage?: number;

  /**
   * Maximum number of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#maxConcurrentCount
   */
  readonly maxConcurrentCount?: number;

  /**
   * Maximum percentage of accounts in which to perform this operation at one time.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#maxConcurrentPercentage
   */
  readonly maxConcurrentPercentage?: number;

  /**
   * Concurrency type of deploying StackSets operations in Regions, could be in parallel or one Region at a time. Valid values are SEQUENTIAL and PARALLEL.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#regionConcurrencyType
   */
  readonly regionConcurrencyType?: string;

  /**
   * Order of the Regions in where you want to perform the stack operation.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderOperationPreferences#regionOrder
   */
  readonly regionOrder?: string[];

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderOperationPreferences' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderOperationPreferences(obj: StackSetInstanceV1Beta2SpecInitProviderOperationPreferences | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureToleranceCount': obj.failureToleranceCount,
    'failureTolerancePercentage': obj.failureTolerancePercentage,
    'maxConcurrentCount': obj.maxConcurrentCount,
    'maxConcurrentPercentage': obj.maxConcurrentPercentage,
    'regionConcurrencyType': obj.regionConcurrencyType,
    'regionOrder': obj.regionOrder?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef
 */
export interface StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef(obj: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a StackSet in cloudformation to populate stackSetName.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector
 */
export interface StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector(obj: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceV1Beta2SpecProviderConfigRefPolicy
 */
export interface StackSetInstanceV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecProviderConfigRefPolicy(obj: StackSetInstanceV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata(obj: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy
 */
export interface StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy(obj: StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy
 */
export interface StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy(obj: StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy
 */
export interface StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy(obj: StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy
 */
export interface StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy(obj: StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecForProviderStackSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecForProviderStackSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecInitProviderStackSetNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecInitProviderStackSetNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum StackSetInstanceV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

