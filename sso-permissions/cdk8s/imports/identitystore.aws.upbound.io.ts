// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Group is the Schema for the Groups API.
 *
 * @schema Group
 */
export class Group extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Group"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identitystore.aws.upbound.io/v1beta1',
    kind: 'Group',
  }

  /**
   * Renders a Kubernetes manifest for "Group".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupProps): any {
    return {
      ...Group.GVK,
      ...toJson_GroupProps(props),
    };
  }

  /**
   * Defines a "Group" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupProps) {
    super(scope, id, {
      ...Group.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Group.GVK,
      ...toJson_GroupProps(resolved),
    };
  }
}

/**
 * Group is the Schema for the Groups API.
 *
 * @schema Group
 */
export interface GroupProps {
  /**
   * @schema Group#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GroupSpec defines the desired state of Group
   *
   * @schema Group#spec
   */
  readonly spec: GroupSpec;

}

/**
 * Converts an object of type 'GroupProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupProps(obj: GroupProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupSpec defines the desired state of Group
 *
 * @schema GroupSpec
 */
export interface GroupSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupSpecDeletionPolicy;

  /**
   * @schema GroupSpec#forProvider
   */
  readonly forProvider: GroupSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema GroupSpec#initProvider
   */
  readonly initProvider?: GroupSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GroupSpec#managementPolicies
   */
  readonly managementPolicies?: GroupSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema GroupSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema GroupSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema GroupSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpec(obj: GroupSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupSpecForProvider(obj.forProvider),
    'initProvider': toJson_GroupSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GroupSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GroupSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupSpecDeletionPolicy
 */
export enum GroupSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GroupSpecForProvider
 */
export interface GroupSpecForProvider {
  /**
   * A string containing the description of the group.
   *
   * @schema GroupSpecForProvider#description
   */
  readonly description?: string;

  /**
   * A string containing the name of the group. This value is commonly displayed when the group is referenced.
   *
   * @schema GroupSpecForProvider#displayName
   */
  readonly displayName: string;

  /**
   * The globally unique identifier for the identity store.
   *
   * @schema GroupSpecForProvider#identityStoreId
   */
  readonly identityStoreId: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GroupSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GroupSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecForProvider(obj: GroupSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'displayName': obj.displayName,
    'identityStoreId': obj.identityStoreId,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema GroupSpecInitProvider
 */
export interface GroupSpecInitProvider {
  /**
   * A string containing the description of the group.
   *
   * @schema GroupSpecInitProvider#description
   */
  readonly description?: string;

}

/**
 * Converts an object of type 'GroupSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecInitProvider(obj: GroupSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema GroupSpecManagementPolicies
 */
export enum GroupSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema GroupSpecProviderConfigRef
 */
export interface GroupSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecProviderConfigRef#policy
   */
  readonly policy?: GroupSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRef(obj: GroupSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema GroupSpecPublishConnectionDetailsTo
 */
export interface GroupSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsTo(obj: GroupSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema GroupSpecWriteConnectionSecretToRef
 */
export interface GroupSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecWriteConnectionSecretToRef(obj: GroupSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupSpecProviderConfigRefPolicy
 */
export interface GroupSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecProviderConfigRefPolicy(obj: GroupSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRef(obj: GroupSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupSpecPublishConnectionDetailsToMetadata
 */
export interface GroupSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToMetadata(obj: GroupSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolution
 */
export enum GroupSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupSpecProviderConfigRefPolicyResolve
 */
export enum GroupSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * GroupMembership is the Schema for the GroupMemberships API.
 *
 * @schema GroupMembership
 */
export class GroupMembership extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GroupMembership"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identitystore.aws.upbound.io/v1beta1',
    kind: 'GroupMembership',
  }

  /**
   * Renders a Kubernetes manifest for "GroupMembership".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GroupMembershipProps): any {
    return {
      ...GroupMembership.GVK,
      ...toJson_GroupMembershipProps(props),
    };
  }

  /**
   * Defines a "GroupMembership" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GroupMembershipProps) {
    super(scope, id, {
      ...GroupMembership.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GroupMembership.GVK,
      ...toJson_GroupMembershipProps(resolved),
    };
  }
}

/**
 * GroupMembership is the Schema for the GroupMemberships API.
 *
 * @schema GroupMembership
 */
export interface GroupMembershipProps {
  /**
   * @schema GroupMembership#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * GroupMembershipSpec defines the desired state of GroupMembership
   *
   * @schema GroupMembership#spec
   */
  readonly spec: GroupMembershipSpec;

}

/**
 * Converts an object of type 'GroupMembershipProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipProps(obj: GroupMembershipProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GroupMembershipSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * GroupMembershipSpec defines the desired state of GroupMembership
 *
 * @schema GroupMembershipSpec
 */
export interface GroupMembershipSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema GroupMembershipSpec#deletionPolicy
   */
  readonly deletionPolicy?: GroupMembershipSpecDeletionPolicy;

  /**
   * @schema GroupMembershipSpec#forProvider
   */
  readonly forProvider: GroupMembershipSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema GroupMembershipSpec#initProvider
   */
  readonly initProvider?: GroupMembershipSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema GroupMembershipSpec#managementPolicies
   */
  readonly managementPolicies?: GroupMembershipSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema GroupMembershipSpec#providerConfigRef
   */
  readonly providerConfigRef?: GroupMembershipSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema GroupMembershipSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: GroupMembershipSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema GroupMembershipSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: GroupMembershipSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'GroupMembershipSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpec(obj: GroupMembershipSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_GroupMembershipSpecForProvider(obj.forProvider),
    'initProvider': toJson_GroupMembershipSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_GroupMembershipSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_GroupMembershipSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_GroupMembershipSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema GroupMembershipSpecDeletionPolicy
 */
export enum GroupMembershipSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema GroupMembershipSpecForProvider
 */
export interface GroupMembershipSpecForProvider {
  /**
   * The identifier for a group in the Identity Store.
   *
   * @schema GroupMembershipSpecForProvider#groupId
   */
  readonly groupId?: string;

  /**
   * Reference to a Group in identitystore to populate groupId.
   *
   * @schema GroupMembershipSpecForProvider#groupIdRef
   */
  readonly groupIdRef?: GroupMembershipSpecForProviderGroupIdRef;

  /**
   * Selector for a Group in identitystore to populate groupId.
   *
   * @schema GroupMembershipSpecForProvider#groupIdSelector
   */
  readonly groupIdSelector?: GroupMembershipSpecForProviderGroupIdSelector;

  /**
   * Identity Store ID associated with the Single Sign-On Instance.
   *
   * @schema GroupMembershipSpecForProvider#identityStoreId
   */
  readonly identityStoreId: string;

  /**
   * The identifier for a user in the Identity Store.
   *
   * @schema GroupMembershipSpecForProvider#memberId
   */
  readonly memberId?: string;

  /**
   * Reference to a User in identitystore to populate memberId.
   *
   * @schema GroupMembershipSpecForProvider#memberIdRef
   */
  readonly memberIdRef?: GroupMembershipSpecForProviderMemberIdRef;

  /**
   * Selector for a User in identitystore to populate memberId.
   *
   * @schema GroupMembershipSpecForProvider#memberIdSelector
   */
  readonly memberIdSelector?: GroupMembershipSpecForProviderMemberIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema GroupMembershipSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProvider(obj: GroupMembershipSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupId': obj.groupId,
    'groupIdRef': toJson_GroupMembershipSpecForProviderGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_GroupMembershipSpecForProviderGroupIdSelector(obj.groupIdSelector),
    'identityStoreId': obj.identityStoreId,
    'memberId': obj.memberId,
    'memberIdRef': toJson_GroupMembershipSpecForProviderMemberIdRef(obj.memberIdRef),
    'memberIdSelector': toJson_GroupMembershipSpecForProviderMemberIdSelector(obj.memberIdSelector),
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema GroupMembershipSpecInitProvider
 */
export interface GroupMembershipSpecInitProvider {
  /**
   * The identifier for a group in the Identity Store.
   *
   * @schema GroupMembershipSpecInitProvider#groupId
   */
  readonly groupId?: string;

  /**
   * Reference to a Group in identitystore to populate groupId.
   *
   * @schema GroupMembershipSpecInitProvider#groupIdRef
   */
  readonly groupIdRef?: GroupMembershipSpecInitProviderGroupIdRef;

  /**
   * Selector for a Group in identitystore to populate groupId.
   *
   * @schema GroupMembershipSpecInitProvider#groupIdSelector
   */
  readonly groupIdSelector?: GroupMembershipSpecInitProviderGroupIdSelector;

  /**
   * The identifier for a user in the Identity Store.
   *
   * @schema GroupMembershipSpecInitProvider#memberId
   */
  readonly memberId?: string;

  /**
   * Reference to a User in identitystore to populate memberId.
   *
   * @schema GroupMembershipSpecInitProvider#memberIdRef
   */
  readonly memberIdRef?: GroupMembershipSpecInitProviderMemberIdRef;

  /**
   * Selector for a User in identitystore to populate memberId.
   *
   * @schema GroupMembershipSpecInitProvider#memberIdSelector
   */
  readonly memberIdSelector?: GroupMembershipSpecInitProviderMemberIdSelector;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProvider(obj: GroupMembershipSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'groupId': obj.groupId,
    'groupIdRef': toJson_GroupMembershipSpecInitProviderGroupIdRef(obj.groupIdRef),
    'groupIdSelector': toJson_GroupMembershipSpecInitProviderGroupIdSelector(obj.groupIdSelector),
    'memberId': obj.memberId,
    'memberIdRef': toJson_GroupMembershipSpecInitProviderMemberIdRef(obj.memberIdRef),
    'memberIdSelector': toJson_GroupMembershipSpecInitProviderMemberIdSelector(obj.memberIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema GroupMembershipSpecManagementPolicies
 */
export enum GroupMembershipSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema GroupMembershipSpecProviderConfigRef
 */
export interface GroupMembershipSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecProviderConfigRef#policy
   */
  readonly policy?: GroupMembershipSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecProviderConfigRef(obj: GroupMembershipSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsTo
 */
export interface GroupMembershipSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: GroupMembershipSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: GroupMembershipSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GroupMembershipSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecPublishConnectionDetailsTo(obj: GroupMembershipSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_GroupMembershipSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_GroupMembershipSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema GroupMembershipSpecWriteConnectionSecretToRef
 */
export interface GroupMembershipSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema GroupMembershipSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema GroupMembershipSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GroupMembershipSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecWriteConnectionSecretToRef(obj: GroupMembershipSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in identitystore to populate groupId.
 *
 * @schema GroupMembershipSpecForProviderGroupIdRef
 */
export interface GroupMembershipSpecForProviderGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecForProviderGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecForProviderGroupIdRef#policy
   */
  readonly policy?: GroupMembershipSpecForProviderGroupIdRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderGroupIdRef(obj: GroupMembershipSpecForProviderGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecForProviderGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in identitystore to populate groupId.
 *
 * @schema GroupMembershipSpecForProviderGroupIdSelector
 */
export interface GroupMembershipSpecForProviderGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema GroupMembershipSpecForProviderGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupMembershipSpecForProviderGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupMembershipSpecForProviderGroupIdSelector#policy
   */
  readonly policy?: GroupMembershipSpecForProviderGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderGroupIdSelector(obj: GroupMembershipSpecForProviderGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupMembershipSpecForProviderGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in identitystore to populate memberId.
 *
 * @schema GroupMembershipSpecForProviderMemberIdRef
 */
export interface GroupMembershipSpecForProviderMemberIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecForProviderMemberIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecForProviderMemberIdRef#policy
   */
  readonly policy?: GroupMembershipSpecForProviderMemberIdRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderMemberIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderMemberIdRef(obj: GroupMembershipSpecForProviderMemberIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecForProviderMemberIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in identitystore to populate memberId.
 *
 * @schema GroupMembershipSpecForProviderMemberIdSelector
 */
export interface GroupMembershipSpecForProviderMemberIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema GroupMembershipSpecForProviderMemberIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupMembershipSpecForProviderMemberIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupMembershipSpecForProviderMemberIdSelector#policy
   */
  readonly policy?: GroupMembershipSpecForProviderMemberIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderMemberIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderMemberIdSelector(obj: GroupMembershipSpecForProviderMemberIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupMembershipSpecForProviderMemberIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Group in identitystore to populate groupId.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdRef
 */
export interface GroupMembershipSpecInitProviderGroupIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdRef#policy
   */
  readonly policy?: GroupMembershipSpecInitProviderGroupIdRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderGroupIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderGroupIdRef(obj: GroupMembershipSpecInitProviderGroupIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecInitProviderGroupIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Group in identitystore to populate groupId.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdSelector
 */
export interface GroupMembershipSpecInitProviderGroupIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdSelector#policy
   */
  readonly policy?: GroupMembershipSpecInitProviderGroupIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderGroupIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderGroupIdSelector(obj: GroupMembershipSpecInitProviderGroupIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupMembershipSpecInitProviderGroupIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a User in identitystore to populate memberId.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdRef
 */
export interface GroupMembershipSpecInitProviderMemberIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdRef#policy
   */
  readonly policy?: GroupMembershipSpecInitProviderMemberIdRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderMemberIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderMemberIdRef(obj: GroupMembershipSpecInitProviderMemberIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecInitProviderMemberIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a User in identitystore to populate memberId.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdSelector
 */
export interface GroupMembershipSpecInitProviderMemberIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdSelector#policy
   */
  readonly policy?: GroupMembershipSpecInitProviderMemberIdSelectorPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderMemberIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderMemberIdSelector(obj: GroupMembershipSpecInitProviderMemberIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_GroupMembershipSpecInitProviderMemberIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecProviderConfigRefPolicy
 */
export interface GroupMembershipSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecProviderConfigRefPolicy(obj: GroupMembershipSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRef
 */
export interface GroupMembershipSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'GroupMembershipSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecPublishConnectionDetailsToConfigRef(obj: GroupMembershipSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsToMetadata
 */
export interface GroupMembershipSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'GroupMembershipSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecPublishConnectionDetailsToMetadata(obj: GroupMembershipSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecForProviderGroupIdRefPolicy
 */
export interface GroupMembershipSpecForProviderGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecForProviderGroupIdRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecForProviderGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecForProviderGroupIdRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecForProviderGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderGroupIdRefPolicy(obj: GroupMembershipSpecForProviderGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupMembershipSpecForProviderGroupIdSelectorPolicy
 */
export interface GroupMembershipSpecForProviderGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecForProviderGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecForProviderGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecForProviderGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecForProviderGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderGroupIdSelectorPolicy(obj: GroupMembershipSpecForProviderGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecForProviderMemberIdRefPolicy
 */
export interface GroupMembershipSpecForProviderMemberIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecForProviderMemberIdRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecForProviderMemberIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecForProviderMemberIdRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecForProviderMemberIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderMemberIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderMemberIdRefPolicy(obj: GroupMembershipSpecForProviderMemberIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupMembershipSpecForProviderMemberIdSelectorPolicy
 */
export interface GroupMembershipSpecForProviderMemberIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecForProviderMemberIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecForProviderMemberIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecForProviderMemberIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecForProviderMemberIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecForProviderMemberIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecForProviderMemberIdSelectorPolicy(obj: GroupMembershipSpecForProviderMemberIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdRefPolicy
 */
export interface GroupMembershipSpecInitProviderGroupIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecInitProviderGroupIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecInitProviderGroupIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderGroupIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderGroupIdRefPolicy(obj: GroupMembershipSpecInitProviderGroupIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdSelectorPolicy
 */
export interface GroupMembershipSpecInitProviderGroupIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecInitProviderGroupIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderGroupIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderGroupIdSelectorPolicy(obj: GroupMembershipSpecInitProviderGroupIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdRefPolicy
 */
export interface GroupMembershipSpecInitProviderMemberIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecInitProviderMemberIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecInitProviderMemberIdRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderMemberIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderMemberIdRefPolicy(obj: GroupMembershipSpecInitProviderMemberIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdSelectorPolicy
 */
export interface GroupMembershipSpecInitProviderMemberIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdSelectorPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecInitProviderMemberIdSelectorPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecInitProviderMemberIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecInitProviderMemberIdSelectorPolicy(obj: GroupMembershipSpecInitProviderMemberIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecProviderConfigRefPolicyResolution
 */
export enum GroupMembershipSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecProviderConfigRefPolicyResolve
 */
export enum GroupMembershipSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy(obj: GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecForProviderGroupIdRefPolicyResolution
 */
export enum GroupMembershipSpecForProviderGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecForProviderGroupIdRefPolicyResolve
 */
export enum GroupMembershipSpecForProviderGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecForProviderGroupIdSelectorPolicyResolution
 */
export enum GroupMembershipSpecForProviderGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecForProviderGroupIdSelectorPolicyResolve
 */
export enum GroupMembershipSpecForProviderGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecForProviderMemberIdRefPolicyResolution
 */
export enum GroupMembershipSpecForProviderMemberIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecForProviderMemberIdRefPolicyResolve
 */
export enum GroupMembershipSpecForProviderMemberIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecForProviderMemberIdSelectorPolicyResolution
 */
export enum GroupMembershipSpecForProviderMemberIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecForProviderMemberIdSelectorPolicyResolve
 */
export enum GroupMembershipSpecForProviderMemberIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdRefPolicyResolution
 */
export enum GroupMembershipSpecInitProviderGroupIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdRefPolicyResolve
 */
export enum GroupMembershipSpecInitProviderGroupIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolution
 */
export enum GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolve
 */
export enum GroupMembershipSpecInitProviderGroupIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdRefPolicyResolution
 */
export enum GroupMembershipSpecInitProviderMemberIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdRefPolicyResolve
 */
export enum GroupMembershipSpecInitProviderMemberIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolution
 */
export enum GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolve
 */
export enum GroupMembershipSpecInitProviderMemberIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum GroupMembershipSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API.
 *
 * @schema User
 */
export class User extends ApiObject {
  /**
   * Returns the apiVersion and kind for "User"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identitystore.aws.upbound.io/v1beta1',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "User".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserProps): any {
    return {
      ...User.GVK,
      ...toJson_UserProps(props),
    };
  }

  /**
   * Defines a "User" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserProps) {
    super(scope, id, {
      ...User.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...User.GVK,
      ...toJson_UserProps(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API.
 *
 * @schema User
 */
export interface UserProps {
  /**
   * @schema User#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema User#spec
   */
  readonly spec: UserSpec;

}

/**
 * Converts an object of type 'UserProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserProps(obj: UserProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserSpec
 */
export interface UserSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserSpec#deletionPolicy
   */
  readonly deletionPolicy?: UserSpecDeletionPolicy;

  /**
   * @schema UserSpec#forProvider
   */
  readonly forProvider: UserSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema UserSpec#initProvider
   */
  readonly initProvider?: UserSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserSpec#managementPolicies
   */
  readonly managementPolicies?: UserSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema UserSpec#providerConfigRef
   */
  readonly providerConfigRef?: UserSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema UserSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema UserSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpec(obj: UserSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserSpecForProvider(obj.forProvider),
    'initProvider': toJson_UserSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserSpecDeletionPolicy
 */
export enum UserSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserSpecForProvider
 */
export interface UserSpecForProvider {
  /**
   * Details about the user's address. At most 1 address is allowed. Detailed below.
   *
   * @schema UserSpecForProvider#addresses
   */
  readonly addresses?: UserSpecForProviderAddresses[];

  /**
   * The name that is typically displayed when the user is referenced.
   *
   * @schema UserSpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Details about the user's email. At most 1 email is allowed. Detailed below.
   *
   * @schema UserSpecForProvider#emails
   */
  readonly emails?: UserSpecForProviderEmails[];

  /**
   * The globally unique identifier for the identity store that this user is in.
   *
   * @schema UserSpecForProvider#identityStoreId
   */
  readonly identityStoreId: string;

  /**
   * The user's geographical region or location.
   *
   * @schema UserSpecForProvider#locale
   */
  readonly locale?: string;

  /**
   * Details about the user's full name. Detailed below.
   *
   * @schema UserSpecForProvider#name
   */
  readonly name?: UserSpecForProviderName[];

  /**
   * An alternate name for the user.
   *
   * @schema UserSpecForProvider#nickname
   */
  readonly nickname?: string;

  /**
   * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
   *
   * @schema UserSpecForProvider#phoneNumbers
   */
  readonly phoneNumbers?: UserSpecForProviderPhoneNumbers[];

  /**
   * The preferred language of the user.
   *
   * @schema UserSpecForProvider#preferredLanguage
   */
  readonly preferredLanguage?: string;

  /**
   * An URL that may be associated with the user.
   *
   * @schema UserSpecForProvider#profileUrl
   */
  readonly profileUrl?: string;

  /**
   * The region of the address.
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserSpecForProvider#region
   */
  readonly region: string;

  /**
   * The user's time zone.
   *
   * @schema UserSpecForProvider#timezone
   */
  readonly timezone?: string;

  /**
   * The user's title.
   *
   * @schema UserSpecForProvider#title
   */
  readonly title?: string;

  /**
   * A unique string used to identify the user. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store. The limit is 128 characters.
   *
   * @schema UserSpecForProvider#userName
   */
  readonly userName?: string;

  /**
   * The user type.
   *
   * @schema UserSpecForProvider#userType
   */
  readonly userType?: string;

}

/**
 * Converts an object of type 'UserSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProvider(obj: UserSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => toJson_UserSpecForProviderAddresses(y)),
    'displayName': obj.displayName,
    'emails': obj.emails?.map(y => toJson_UserSpecForProviderEmails(y)),
    'identityStoreId': obj.identityStoreId,
    'locale': obj.locale,
    'name': obj.name?.map(y => toJson_UserSpecForProviderName(y)),
    'nickname': obj.nickname,
    'phoneNumbers': obj.phoneNumbers?.map(y => toJson_UserSpecForProviderPhoneNumbers(y)),
    'preferredLanguage': obj.preferredLanguage,
    'profileUrl': obj.profileUrl,
    'region': obj.region,
    'timezone': obj.timezone,
    'title': obj.title,
    'userName': obj.userName,
    'userType': obj.userType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema UserSpecInitProvider
 */
export interface UserSpecInitProvider {
  /**
   * Details about the user's address. At most 1 address is allowed. Detailed below.
   *
   * @schema UserSpecInitProvider#addresses
   */
  readonly addresses?: UserSpecInitProviderAddresses[];

  /**
   * The name that is typically displayed when the user is referenced.
   *
   * @schema UserSpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Details about the user's email. At most 1 email is allowed. Detailed below.
   *
   * @schema UserSpecInitProvider#emails
   */
  readonly emails?: UserSpecInitProviderEmails[];

  /**
   * The user's geographical region or location.
   *
   * @schema UserSpecInitProvider#locale
   */
  readonly locale?: string;

  /**
   * Details about the user's full name. Detailed below.
   *
   * @schema UserSpecInitProvider#name
   */
  readonly name?: UserSpecInitProviderName[];

  /**
   * An alternate name for the user.
   *
   * @schema UserSpecInitProvider#nickname
   */
  readonly nickname?: string;

  /**
   * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
   *
   * @schema UserSpecInitProvider#phoneNumbers
   */
  readonly phoneNumbers?: UserSpecInitProviderPhoneNumbers[];

  /**
   * The preferred language of the user.
   *
   * @schema UserSpecInitProvider#preferredLanguage
   */
  readonly preferredLanguage?: string;

  /**
   * An URL that may be associated with the user.
   *
   * @schema UserSpecInitProvider#profileUrl
   */
  readonly profileUrl?: string;

  /**
   * The user's time zone.
   *
   * @schema UserSpecInitProvider#timezone
   */
  readonly timezone?: string;

  /**
   * The user's title.
   *
   * @schema UserSpecInitProvider#title
   */
  readonly title?: string;

  /**
   * A unique string used to identify the user. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store. The limit is 128 characters.
   *
   * @schema UserSpecInitProvider#userName
   */
  readonly userName?: string;

  /**
   * The user type.
   *
   * @schema UserSpecInitProvider#userType
   */
  readonly userType?: string;

}

/**
 * Converts an object of type 'UserSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProvider(obj: UserSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': obj.addresses?.map(y => toJson_UserSpecInitProviderAddresses(y)),
    'displayName': obj.displayName,
    'emails': obj.emails?.map(y => toJson_UserSpecInitProviderEmails(y)),
    'locale': obj.locale,
    'name': obj.name?.map(y => toJson_UserSpecInitProviderName(y)),
    'nickname': obj.nickname,
    'phoneNumbers': obj.phoneNumbers?.map(y => toJson_UserSpecInitProviderPhoneNumbers(y)),
    'preferredLanguage': obj.preferredLanguage,
    'profileUrl': obj.profileUrl,
    'timezone': obj.timezone,
    'title': obj.title,
    'userName': obj.userName,
    'userType': obj.userType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema UserSpecManagementPolicies
 */
export enum UserSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema UserSpecProviderConfigRef
 */
export interface UserSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecProviderConfigRef#policy
   */
  readonly policy?: UserSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRef(obj: UserSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema UserSpecPublishConnectionDetailsTo
 */
export interface UserSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsTo(obj: UserSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema UserSpecWriteConnectionSecretToRef
 */
export interface UserSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecWriteConnectionSecretToRef(obj: UserSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderAddresses
 */
export interface UserSpecForProviderAddresses {
  /**
   * The country that this address is in.
   *
   * @schema UserSpecForProviderAddresses#country
   */
  readonly country?: string;

  /**
   * The name that is typically displayed when the address is shown for display.
   *
   * @schema UserSpecForProviderAddresses#formatted
   */
  readonly formatted?: string;

  /**
   * The address locality.
   *
   * @schema UserSpecForProviderAddresses#locality
   */
  readonly locality?: string;

  /**
   * The postal code of the address.
   *
   * @schema UserSpecForProviderAddresses#postalCode
   */
  readonly postalCode?: string;

  /**
   * When true, this is the primary address associated with the user.
   *
   * @schema UserSpecForProviderAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * The region of the address.
   *
   * @schema UserSpecForProviderAddresses#region
   */
  readonly region?: string;

  /**
   * The street of the address.
   *
   * @schema UserSpecForProviderAddresses#streetAddress
   */
  readonly streetAddress?: string;

  /**
   * The type of address.
   *
   * @schema UserSpecForProviderAddresses#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderAddresses(obj: UserSpecForProviderAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'country': obj.country,
    'formatted': obj.formatted,
    'locality': obj.locality,
    'postalCode': obj.postalCode,
    'primary': obj.primary,
    'region': obj.region,
    'streetAddress': obj.streetAddress,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderEmails
 */
export interface UserSpecForProviderEmails {
  /**
   * When true, this is the primary email associated with the user.
   *
   * @schema UserSpecForProviderEmails#primary
   */
  readonly primary?: boolean;

  /**
   * The type of email.
   *
   * @schema UserSpecForProviderEmails#type
   */
  readonly type?: string;

  /**
   * The email address. This value must be unique across the identity store.
   *
   * @schema UserSpecForProviderEmails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderEmails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderEmails(obj: UserSpecForProviderEmails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderName
 */
export interface UserSpecForProviderName {
  /**
   * The family name of the user.
   *
   * @schema UserSpecForProviderName#familyName
   */
  readonly familyName?: string;

  /**
   * The name that is typically displayed when the name is shown for display.
   *
   * @schema UserSpecForProviderName#formatted
   */
  readonly formatted?: string;

  /**
   * The given name of the user.
   *
   * @schema UserSpecForProviderName#givenName
   */
  readonly givenName?: string;

  /**
   * The honorific prefix of the user.
   *
   * @schema UserSpecForProviderName#honorificPrefix
   */
  readonly honorificPrefix?: string;

  /**
   * The honorific suffix of the user.
   *
   * @schema UserSpecForProviderName#honorificSuffix
   */
  readonly honorificSuffix?: string;

  /**
   * The middle name of the user.
   *
   * @schema UserSpecForProviderName#middleName
   */
  readonly middleName?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderName(obj: UserSpecForProviderName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'familyName': obj.familyName,
    'formatted': obj.formatted,
    'givenName': obj.givenName,
    'honorificPrefix': obj.honorificPrefix,
    'honorificSuffix': obj.honorificSuffix,
    'middleName': obj.middleName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecForProviderPhoneNumbers
 */
export interface UserSpecForProviderPhoneNumbers {
  /**
   * When true, this is the primary phone number associated with the user.
   *
   * @schema UserSpecForProviderPhoneNumbers#primary
   */
  readonly primary?: boolean;

  /**
   * The type of phone number.
   *
   * @schema UserSpecForProviderPhoneNumbers#type
   */
  readonly type?: string;

  /**
   * The user's phone number.
   *
   * @schema UserSpecForProviderPhoneNumbers#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserSpecForProviderPhoneNumbers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecForProviderPhoneNumbers(obj: UserSpecForProviderPhoneNumbers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderAddresses
 */
export interface UserSpecInitProviderAddresses {
  /**
   * The country that this address is in.
   *
   * @schema UserSpecInitProviderAddresses#country
   */
  readonly country?: string;

  /**
   * The name that is typically displayed when the address is shown for display.
   *
   * @schema UserSpecInitProviderAddresses#formatted
   */
  readonly formatted?: string;

  /**
   * The address locality.
   *
   * @schema UserSpecInitProviderAddresses#locality
   */
  readonly locality?: string;

  /**
   * The postal code of the address.
   *
   * @schema UserSpecInitProviderAddresses#postalCode
   */
  readonly postalCode?: string;

  /**
   * When true, this is the primary address associated with the user.
   *
   * @schema UserSpecInitProviderAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * The street of the address.
   *
   * @schema UserSpecInitProviderAddresses#streetAddress
   */
  readonly streetAddress?: string;

  /**
   * The type of address.
   *
   * @schema UserSpecInitProviderAddresses#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderAddresses(obj: UserSpecInitProviderAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'country': obj.country,
    'formatted': obj.formatted,
    'locality': obj.locality,
    'postalCode': obj.postalCode,
    'primary': obj.primary,
    'streetAddress': obj.streetAddress,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderEmails
 */
export interface UserSpecInitProviderEmails {
  /**
   * When true, this is the primary email associated with the user.
   *
   * @schema UserSpecInitProviderEmails#primary
   */
  readonly primary?: boolean;

  /**
   * The type of email.
   *
   * @schema UserSpecInitProviderEmails#type
   */
  readonly type?: string;

  /**
   * The email address. This value must be unique across the identity store.
   *
   * @schema UserSpecInitProviderEmails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderEmails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderEmails(obj: UserSpecInitProviderEmails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderName
 */
export interface UserSpecInitProviderName {
  /**
   * The family name of the user.
   *
   * @schema UserSpecInitProviderName#familyName
   */
  readonly familyName?: string;

  /**
   * The name that is typically displayed when the name is shown for display.
   *
   * @schema UserSpecInitProviderName#formatted
   */
  readonly formatted?: string;

  /**
   * The given name of the user.
   *
   * @schema UserSpecInitProviderName#givenName
   */
  readonly givenName?: string;

  /**
   * The honorific prefix of the user.
   *
   * @schema UserSpecInitProviderName#honorificPrefix
   */
  readonly honorificPrefix?: string;

  /**
   * The honorific suffix of the user.
   *
   * @schema UserSpecInitProviderName#honorificSuffix
   */
  readonly honorificSuffix?: string;

  /**
   * The middle name of the user.
   *
   * @schema UserSpecInitProviderName#middleName
   */
  readonly middleName?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderName(obj: UserSpecInitProviderName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'familyName': obj.familyName,
    'formatted': obj.formatted,
    'givenName': obj.givenName,
    'honorificPrefix': obj.honorificPrefix,
    'honorificSuffix': obj.honorificSuffix,
    'middleName': obj.middleName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema UserSpecInitProviderPhoneNumbers
 */
export interface UserSpecInitProviderPhoneNumbers {
  /**
   * When true, this is the primary phone number associated with the user.
   *
   * @schema UserSpecInitProviderPhoneNumbers#primary
   */
  readonly primary?: boolean;

  /**
   * The type of phone number.
   *
   * @schema UserSpecInitProviderPhoneNumbers#type
   */
  readonly type?: string;

  /**
   * The user's phone number.
   *
   * @schema UserSpecInitProviderPhoneNumbers#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserSpecInitProviderPhoneNumbers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecInitProviderPhoneNumbers(obj: UserSpecInitProviderPhoneNumbers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserSpecProviderConfigRefPolicy
 */
export interface UserSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema UserSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecProviderConfigRefPolicy(obj: UserSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRef
 */
export interface UserSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRef(obj: UserSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserSpecPublishConnectionDetailsToMetadata
 */
export interface UserSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToMetadata(obj: UserSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema UserSpecProviderConfigRefPolicyResolution
 */
export enum UserSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema UserSpecProviderConfigRefPolicyResolve
 */
export enum UserSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema UserSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserSpecPublishConnectionDetailsToConfigRefPolicy(obj: UserSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema UserSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * User is the Schema for the Users API.
 *
 * @schema UserV1Beta2
 */
export class UserV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "UserV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'identitystore.aws.upbound.io/v1beta2',
    kind: 'User',
  }

  /**
   * Renders a Kubernetes manifest for "UserV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: UserV1Beta2Props): any {
    return {
      ...UserV1Beta2.GVK,
      ...toJson_UserV1Beta2Props(props),
    };
  }

  /**
   * Defines a "UserV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: UserV1Beta2Props) {
    super(scope, id, {
      ...UserV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...UserV1Beta2.GVK,
      ...toJson_UserV1Beta2Props(resolved),
    };
  }
}

/**
 * User is the Schema for the Users API.
 *
 * @schema UserV1Beta2
 */
export interface UserV1Beta2Props {
  /**
   * @schema UserV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * UserSpec defines the desired state of User
   *
   * @schema UserV1Beta2#spec
   */
  readonly spec: UserV1Beta2Spec;

}

/**
 * Converts an object of type 'UserV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2Props(obj: UserV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_UserV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UserSpec defines the desired state of User
 *
 * @schema UserV1Beta2Spec
 */
export interface UserV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema UserV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: UserV1Beta2SpecDeletionPolicy;

  /**
   * @schema UserV1Beta2Spec#forProvider
   */
  readonly forProvider: UserV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema UserV1Beta2Spec#initProvider
   */
  readonly initProvider?: UserV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema UserV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: UserV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema UserV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: UserV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema UserV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: UserV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema UserV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: UserV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'UserV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2Spec(obj: UserV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_UserV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_UserV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_UserV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_UserV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_UserV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema UserV1Beta2SpecDeletionPolicy
 */
export enum UserV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema UserV1Beta2SpecForProvider
 */
export interface UserV1Beta2SpecForProvider {
  /**
   * Details about the user's address. At most 1 address is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecForProvider#addresses
   */
  readonly addresses?: UserV1Beta2SpecForProviderAddresses;

  /**
   * The name that is typically displayed when the user is referenced.
   *
   * @schema UserV1Beta2SpecForProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Details about the user's email. At most 1 email is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecForProvider#emails
   */
  readonly emails?: UserV1Beta2SpecForProviderEmails;

  /**
   * The globally unique identifier for the identity store that this user is in.
   *
   * @schema UserV1Beta2SpecForProvider#identityStoreId
   */
  readonly identityStoreId: string;

  /**
   * The user's geographical region or location.
   *
   * @schema UserV1Beta2SpecForProvider#locale
   */
  readonly locale?: string;

  /**
   * Details about the user's full name. Detailed below.
   *
   * @schema UserV1Beta2SpecForProvider#name
   */
  readonly name?: UserV1Beta2SpecForProviderName;

  /**
   * An alternate name for the user.
   *
   * @schema UserV1Beta2SpecForProvider#nickname
   */
  readonly nickname?: string;

  /**
   * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecForProvider#phoneNumbers
   */
  readonly phoneNumbers?: UserV1Beta2SpecForProviderPhoneNumbers;

  /**
   * The preferred language of the user.
   *
   * @schema UserV1Beta2SpecForProvider#preferredLanguage
   */
  readonly preferredLanguage?: string;

  /**
   * An URL that may be associated with the user.
   *
   * @schema UserV1Beta2SpecForProvider#profileUrl
   */
  readonly profileUrl?: string;

  /**
   * The region of the address.
   * Region is the region you'd like your resource to be created in.
   *
   * @schema UserV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * The user's time zone.
   *
   * @schema UserV1Beta2SpecForProvider#timezone
   */
  readonly timezone?: string;

  /**
   * The user's title.
   *
   * @schema UserV1Beta2SpecForProvider#title
   */
  readonly title?: string;

  /**
   * A unique string used to identify the user. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store. The limit is 128 characters.
   *
   * @schema UserV1Beta2SpecForProvider#userName
   */
  readonly userName?: string;

  /**
   * The user type.
   *
   * @schema UserV1Beta2SpecForProvider#userType
   */
  readonly userType?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecForProvider(obj: UserV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': toJson_UserV1Beta2SpecForProviderAddresses(obj.addresses),
    'displayName': obj.displayName,
    'emails': toJson_UserV1Beta2SpecForProviderEmails(obj.emails),
    'identityStoreId': obj.identityStoreId,
    'locale': obj.locale,
    'name': toJson_UserV1Beta2SpecForProviderName(obj.name),
    'nickname': obj.nickname,
    'phoneNumbers': toJson_UserV1Beta2SpecForProviderPhoneNumbers(obj.phoneNumbers),
    'preferredLanguage': obj.preferredLanguage,
    'profileUrl': obj.profileUrl,
    'region': obj.region,
    'timezone': obj.timezone,
    'title': obj.title,
    'userName': obj.userName,
    'userType': obj.userType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema UserV1Beta2SpecInitProvider
 */
export interface UserV1Beta2SpecInitProvider {
  /**
   * Details about the user's address. At most 1 address is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecInitProvider#addresses
   */
  readonly addresses?: UserV1Beta2SpecInitProviderAddresses;

  /**
   * The name that is typically displayed when the user is referenced.
   *
   * @schema UserV1Beta2SpecInitProvider#displayName
   */
  readonly displayName?: string;

  /**
   * Details about the user's email. At most 1 email is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecInitProvider#emails
   */
  readonly emails?: UserV1Beta2SpecInitProviderEmails;

  /**
   * The user's geographical region or location.
   *
   * @schema UserV1Beta2SpecInitProvider#locale
   */
  readonly locale?: string;

  /**
   * Details about the user's full name. Detailed below.
   *
   * @schema UserV1Beta2SpecInitProvider#name
   */
  readonly name?: UserV1Beta2SpecInitProviderName;

  /**
   * An alternate name for the user.
   *
   * @schema UserV1Beta2SpecInitProvider#nickname
   */
  readonly nickname?: string;

  /**
   * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
   *
   * @schema UserV1Beta2SpecInitProvider#phoneNumbers
   */
  readonly phoneNumbers?: UserV1Beta2SpecInitProviderPhoneNumbers;

  /**
   * The preferred language of the user.
   *
   * @schema UserV1Beta2SpecInitProvider#preferredLanguage
   */
  readonly preferredLanguage?: string;

  /**
   * An URL that may be associated with the user.
   *
   * @schema UserV1Beta2SpecInitProvider#profileUrl
   */
  readonly profileUrl?: string;

  /**
   * The user's time zone.
   *
   * @schema UserV1Beta2SpecInitProvider#timezone
   */
  readonly timezone?: string;

  /**
   * The user's title.
   *
   * @schema UserV1Beta2SpecInitProvider#title
   */
  readonly title?: string;

  /**
   * A unique string used to identify the user. This value can consist of letters, accented characters, symbols, numbers, and punctuation. This value is specified at the time the user is created and stored as an attribute of the user object in the identity store. The limit is 128 characters.
   *
   * @schema UserV1Beta2SpecInitProvider#userName
   */
  readonly userName?: string;

  /**
   * The user type.
   *
   * @schema UserV1Beta2SpecInitProvider#userType
   */
  readonly userType?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecInitProvider(obj: UserV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'addresses': toJson_UserV1Beta2SpecInitProviderAddresses(obj.addresses),
    'displayName': obj.displayName,
    'emails': toJson_UserV1Beta2SpecInitProviderEmails(obj.emails),
    'locale': obj.locale,
    'name': toJson_UserV1Beta2SpecInitProviderName(obj.name),
    'nickname': obj.nickname,
    'phoneNumbers': toJson_UserV1Beta2SpecInitProviderPhoneNumbers(obj.phoneNumbers),
    'preferredLanguage': obj.preferredLanguage,
    'profileUrl': obj.profileUrl,
    'timezone': obj.timezone,
    'title': obj.title,
    'userName': obj.userName,
    'userType': obj.userType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema UserV1Beta2SpecManagementPolicies
 */
export enum UserV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema UserV1Beta2SpecProviderConfigRef
 */
export interface UserV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: UserV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'UserV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecProviderConfigRef(obj: UserV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsTo
 */
export interface UserV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: UserV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: UserV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecPublishConnectionDetailsTo(obj: UserV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_UserV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_UserV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema UserV1Beta2SpecWriteConnectionSecretToRef
 */
export interface UserV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema UserV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema UserV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecWriteConnectionSecretToRef(obj: UserV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's address. At most 1 address is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecForProviderAddresses
 */
export interface UserV1Beta2SpecForProviderAddresses {
  /**
   * The country that this address is in.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#country
   */
  readonly country?: string;

  /**
   * The name that is typically displayed when the address is shown for display.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#formatted
   */
  readonly formatted?: string;

  /**
   * The address locality.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#locality
   */
  readonly locality?: string;

  /**
   * The postal code of the address.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#postalCode
   */
  readonly postalCode?: string;

  /**
   * When true, this is the primary address associated with the user.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * The region of the address.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#region
   */
  readonly region?: string;

  /**
   * The street of the address.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#streetAddress
   */
  readonly streetAddress?: string;

  /**
   * The type of address.
   *
   * @schema UserV1Beta2SpecForProviderAddresses#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecForProviderAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecForProviderAddresses(obj: UserV1Beta2SpecForProviderAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'country': obj.country,
    'formatted': obj.formatted,
    'locality': obj.locality,
    'postalCode': obj.postalCode,
    'primary': obj.primary,
    'region': obj.region,
    'streetAddress': obj.streetAddress,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's email. At most 1 email is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecForProviderEmails
 */
export interface UserV1Beta2SpecForProviderEmails {
  /**
   * When true, this is the primary email associated with the user.
   *
   * @schema UserV1Beta2SpecForProviderEmails#primary
   */
  readonly primary?: boolean;

  /**
   * The type of email.
   *
   * @schema UserV1Beta2SpecForProviderEmails#type
   */
  readonly type?: string;

  /**
   * The email address. This value must be unique across the identity store.
   *
   * @schema UserV1Beta2SpecForProviderEmails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecForProviderEmails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecForProviderEmails(obj: UserV1Beta2SpecForProviderEmails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's full name. Detailed below.
 *
 * @schema UserV1Beta2SpecForProviderName
 */
export interface UserV1Beta2SpecForProviderName {
  /**
   * The family name of the user.
   *
   * @schema UserV1Beta2SpecForProviderName#familyName
   */
  readonly familyName?: string;

  /**
   * The name that is typically displayed when the name is shown for display.
   *
   * @schema UserV1Beta2SpecForProviderName#formatted
   */
  readonly formatted?: string;

  /**
   * The given name of the user.
   *
   * @schema UserV1Beta2SpecForProviderName#givenName
   */
  readonly givenName?: string;

  /**
   * The honorific prefix of the user.
   *
   * @schema UserV1Beta2SpecForProviderName#honorificPrefix
   */
  readonly honorificPrefix?: string;

  /**
   * The honorific suffix of the user.
   *
   * @schema UserV1Beta2SpecForProviderName#honorificSuffix
   */
  readonly honorificSuffix?: string;

  /**
   * The middle name of the user.
   *
   * @schema UserV1Beta2SpecForProviderName#middleName
   */
  readonly middleName?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecForProviderName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecForProviderName(obj: UserV1Beta2SpecForProviderName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'familyName': obj.familyName,
    'formatted': obj.formatted,
    'givenName': obj.givenName,
    'honorificPrefix': obj.honorificPrefix,
    'honorificSuffix': obj.honorificSuffix,
    'middleName': obj.middleName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecForProviderPhoneNumbers
 */
export interface UserV1Beta2SpecForProviderPhoneNumbers {
  /**
   * When true, this is the primary phone number associated with the user.
   *
   * @schema UserV1Beta2SpecForProviderPhoneNumbers#primary
   */
  readonly primary?: boolean;

  /**
   * The type of phone number.
   *
   * @schema UserV1Beta2SpecForProviderPhoneNumbers#type
   */
  readonly type?: string;

  /**
   * The user's phone number.
   *
   * @schema UserV1Beta2SpecForProviderPhoneNumbers#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecForProviderPhoneNumbers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecForProviderPhoneNumbers(obj: UserV1Beta2SpecForProviderPhoneNumbers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's address. At most 1 address is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecInitProviderAddresses
 */
export interface UserV1Beta2SpecInitProviderAddresses {
  /**
   * The country that this address is in.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#country
   */
  readonly country?: string;

  /**
   * The name that is typically displayed when the address is shown for display.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#formatted
   */
  readonly formatted?: string;

  /**
   * The address locality.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#locality
   */
  readonly locality?: string;

  /**
   * The postal code of the address.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#postalCode
   */
  readonly postalCode?: string;

  /**
   * When true, this is the primary address associated with the user.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#primary
   */
  readonly primary?: boolean;

  /**
   * The street of the address.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#streetAddress
   */
  readonly streetAddress?: string;

  /**
   * The type of address.
   *
   * @schema UserV1Beta2SpecInitProviderAddresses#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecInitProviderAddresses' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecInitProviderAddresses(obj: UserV1Beta2SpecInitProviderAddresses | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'country': obj.country,
    'formatted': obj.formatted,
    'locality': obj.locality,
    'postalCode': obj.postalCode,
    'primary': obj.primary,
    'streetAddress': obj.streetAddress,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's email. At most 1 email is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecInitProviderEmails
 */
export interface UserV1Beta2SpecInitProviderEmails {
  /**
   * When true, this is the primary email associated with the user.
   *
   * @schema UserV1Beta2SpecInitProviderEmails#primary
   */
  readonly primary?: boolean;

  /**
   * The type of email.
   *
   * @schema UserV1Beta2SpecInitProviderEmails#type
   */
  readonly type?: string;

  /**
   * The email address. This value must be unique across the identity store.
   *
   * @schema UserV1Beta2SpecInitProviderEmails#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecInitProviderEmails' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecInitProviderEmails(obj: UserV1Beta2SpecInitProviderEmails | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's full name. Detailed below.
 *
 * @schema UserV1Beta2SpecInitProviderName
 */
export interface UserV1Beta2SpecInitProviderName {
  /**
   * The family name of the user.
   *
   * @schema UserV1Beta2SpecInitProviderName#familyName
   */
  readonly familyName?: string;

  /**
   * The name that is typically displayed when the name is shown for display.
   *
   * @schema UserV1Beta2SpecInitProviderName#formatted
   */
  readonly formatted?: string;

  /**
   * The given name of the user.
   *
   * @schema UserV1Beta2SpecInitProviderName#givenName
   */
  readonly givenName?: string;

  /**
   * The honorific prefix of the user.
   *
   * @schema UserV1Beta2SpecInitProviderName#honorificPrefix
   */
  readonly honorificPrefix?: string;

  /**
   * The honorific suffix of the user.
   *
   * @schema UserV1Beta2SpecInitProviderName#honorificSuffix
   */
  readonly honorificSuffix?: string;

  /**
   * The middle name of the user.
   *
   * @schema UserV1Beta2SpecInitProviderName#middleName
   */
  readonly middleName?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecInitProviderName' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecInitProviderName(obj: UserV1Beta2SpecInitProviderName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'familyName': obj.familyName,
    'formatted': obj.formatted,
    'givenName': obj.givenName,
    'honorificPrefix': obj.honorificPrefix,
    'honorificSuffix': obj.honorificSuffix,
    'middleName': obj.middleName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Details about the user's phone number. At most 1 phone number is allowed. Detailed below.
 *
 * @schema UserV1Beta2SpecInitProviderPhoneNumbers
 */
export interface UserV1Beta2SpecInitProviderPhoneNumbers {
  /**
   * When true, this is the primary phone number associated with the user.
   *
   * @schema UserV1Beta2SpecInitProviderPhoneNumbers#primary
   */
  readonly primary?: boolean;

  /**
   * The type of phone number.
   *
   * @schema UserV1Beta2SpecInitProviderPhoneNumbers#type
   */
  readonly type?: string;

  /**
   * The user's phone number.
   *
   * @schema UserV1Beta2SpecInitProviderPhoneNumbers#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecInitProviderPhoneNumbers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecInitProviderPhoneNumbers(obj: UserV1Beta2SpecInitProviderPhoneNumbers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'primary': obj.primary,
    'type': obj.type,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema UserV1Beta2SpecProviderConfigRefPolicy
 */
export interface UserV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema UserV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: UserV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema UserV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: UserV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecProviderConfigRefPolicy(obj: UserV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface UserV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'UserV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: UserV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface UserV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'UserV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecPublishConnectionDetailsToMetadata(obj: UserV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema UserV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum UserV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema UserV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum UserV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum UserV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

