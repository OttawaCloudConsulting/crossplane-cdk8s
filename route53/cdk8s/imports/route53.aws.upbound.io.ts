// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export class Route53Record extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Record"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'Record',
  }

  /**
   * Renders a Kubernetes manifest for "Record".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53RecordProps): any {
    return {
      ...Route53Record.GVK,
      ...toJson_Route53RecordProps(props),
    };
  }

  /**
   * Defines a "Record" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53RecordProps) {
    super(scope, id, {
      ...Route53Record.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53Record.GVK,
      ...toJson_Route53RecordProps(resolved),
    };
  }
}

/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export interface Route53RecordProps {
  /**
   * @schema Record#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSpec defines the desired state of Record
   *
   * @schema Record#spec
   */
  readonly spec: RecordSpec;

}

/**
 * Converts an object of type 'Route53RecordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53RecordProps(obj: Route53RecordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSpec defines the desired state of Record
 *
 * @schema RecordSpec
 */
export interface RecordSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSpec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSpecDeletionPolicy;

  /**
   * @schema RecordSpec#forProvider
   */
  readonly forProvider: RecordSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordSpec#initProvider
   */
  readonly initProvider?: RecordSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordSpec#managementPolicies
   */
  readonly managementPolicies?: RecordSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordSpec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema RecordSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpec(obj: RecordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RecordSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSpecDeletionPolicy
 */
export enum RecordSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSpecForProvider
 */
export interface RecordSpecForProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordSpecForProvider#alias
   */
  readonly alias?: RecordSpecForProviderAlias[];

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordSpecForProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordSpecForProviderCidrRoutingPolicy[];

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordSpecForProviderFailoverRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordSpecForProviderGeolocationRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordSpecForProviderGeoproximityRoutingPolicy[];

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordSpecForProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordSpecForProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordSpecForProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: RecordSpecForProviderLatencyRoutingPolicy[];

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordSpecForProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordSpecForProvider#records
   */
  readonly records?: string[];

  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RecordSpecForProvider#region
   */
  readonly region: string;

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordSpecForProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordSpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordSpecForProviderWeightedRoutingPolicy[];

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProvider(obj: RecordSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias?.map(y => toJson_RecordSpecForProviderAlias(y)),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': obj.cidrRoutingPolicy?.map(y => toJson_RecordSpecForProviderCidrRoutingPolicy(y)),
    'failoverRoutingPolicy': obj.failoverRoutingPolicy?.map(y => toJson_RecordSpecForProviderFailoverRoutingPolicy(y)),
    'geolocationRoutingPolicy': obj.geolocationRoutingPolicy?.map(y => toJson_RecordSpecForProviderGeolocationRoutingPolicy(y)),
    'geoproximityRoutingPolicy': obj.geoproximityRoutingPolicy?.map(y => toJson_RecordSpecForProviderGeoproximityRoutingPolicy(y)),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordSpecForProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordSpecForProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy?.map(y => toJson_RecordSpecForProviderLatencyRoutingPolicy(y)),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'region': obj.region,
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': obj.weightedRoutingPolicy?.map(y => toJson_RecordSpecForProviderWeightedRoutingPolicy(y)),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordSpecInitProvider
 */
export interface RecordSpecInitProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordSpecInitProvider#alias
   */
  readonly alias?: RecordSpecInitProviderAlias[];

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordSpecInitProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordSpecInitProviderCidrRoutingPolicy[];

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordSpecInitProviderFailoverRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordSpecInitProviderGeolocationRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordSpecInitProviderGeoproximityRoutingPolicy[];

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordSpecInitProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecInitProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordSpecInitProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecInitProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordSpecInitProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: any[];

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordSpecInitProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordSpecInitProvider#records
   */
  readonly records?: string[];

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordSpecInitProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordSpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordSpecInitProviderWeightedRoutingPolicy[];

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordSpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordSpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProvider(obj: RecordSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias?.map(y => toJson_RecordSpecInitProviderAlias(y)),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': obj.cidrRoutingPolicy?.map(y => toJson_RecordSpecInitProviderCidrRoutingPolicy(y)),
    'failoverRoutingPolicy': obj.failoverRoutingPolicy?.map(y => toJson_RecordSpecInitProviderFailoverRoutingPolicy(y)),
    'geolocationRoutingPolicy': obj.geolocationRoutingPolicy?.map(y => toJson_RecordSpecInitProviderGeolocationRoutingPolicy(y)),
    'geoproximityRoutingPolicy': obj.geoproximityRoutingPolicy?.map(y => toJson_RecordSpecInitProviderGeoproximityRoutingPolicy(y)),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordSpecInitProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordSpecInitProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy?.map(y => y),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': obj.weightedRoutingPolicy?.map(y => toJson_RecordSpecInitProviderWeightedRoutingPolicy(y)),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordSpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordSpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordSpecManagementPolicies
 */
export enum RecordSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordSpecProviderConfigRef
 */
export interface RecordSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecProviderConfigRef#policy
   */
  readonly policy?: RecordSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRef(obj: RecordSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordSpecPublishConnectionDetailsTo
 */
export interface RecordSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsTo(obj: RecordSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema RecordSpecWriteConnectionSecretToRef
 */
export interface RecordSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecWriteConnectionSecretToRef(obj: RecordSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderAlias
 */
export interface RecordSpecForProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordSpecForProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderAlias(obj: RecordSpecForProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderCidrRoutingPolicy
 */
export interface RecordSpecForProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderCidrRoutingPolicy(obj: RecordSpecForProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderFailoverRoutingPolicy
 */
export interface RecordSpecForProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderFailoverRoutingPolicy(obj: RecordSpecForProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeolocationRoutingPolicy
 */
export interface RecordSpecForProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeolocationRoutingPolicy(obj: RecordSpecForProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeoproximityRoutingPolicy
 */
export interface RecordSpecForProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordSpecForProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeoproximityRoutingPolicy(obj: RecordSpecForProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordSpecForProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdRef
 */
export interface RecordSpecForProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRef(obj: RecordSpecForProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelector
 */
export interface RecordSpecForProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelector(obj: RecordSpecForProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderLatencyRoutingPolicy
 */
export interface RecordSpecForProviderLatencyRoutingPolicy {
  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   *
   * @schema RecordSpecForProviderLatencyRoutingPolicy#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderLatencyRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderLatencyRoutingPolicy(obj: RecordSpecForProviderLatencyRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderWeightedRoutingPolicy
 */
export interface RecordSpecForProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordSpecForProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordSpecForProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderWeightedRoutingPolicy(obj: RecordSpecForProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdRef
 */
export interface RecordSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderZoneIdRef#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRef(obj: RecordSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdSelector
 */
export interface RecordSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelector(obj: RecordSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderAlias
 */
export interface RecordSpecInitProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordSpecInitProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecInitProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecInitProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderAlias(obj: RecordSpecInitProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderCidrRoutingPolicy
 */
export interface RecordSpecInitProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordSpecInitProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordSpecInitProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderCidrRoutingPolicy(obj: RecordSpecInitProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderFailoverRoutingPolicy
 */
export interface RecordSpecInitProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecInitProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderFailoverRoutingPolicy(obj: RecordSpecInitProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeolocationRoutingPolicy
 */
export interface RecordSpecInitProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeolocationRoutingPolicy(obj: RecordSpecInitProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeoproximityRoutingPolicy
 */
export interface RecordSpecInitProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeoproximityRoutingPolicy(obj: RecordSpecInitProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRef
 */
export interface RecordSpecInitProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordSpecInitProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdRef(obj: RecordSpecInitProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecInitProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelector
 */
export interface RecordSpecInitProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordSpecInitProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdSelector(obj: RecordSpecInitProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecInitProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderWeightedRoutingPolicy
 */
export interface RecordSpecInitProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordSpecInitProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordSpecInitProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderWeightedRoutingPolicy(obj: RecordSpecInitProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecInitProviderZoneIdRef
 */
export interface RecordSpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecInitProviderZoneIdRef#policy
   */
  readonly policy?: RecordSpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdRef(obj: RecordSpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecInitProviderZoneIdSelector
 */
export interface RecordSpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: RecordSpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdSelector(obj: RecordSpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecProviderConfigRefPolicy
 */
export interface RecordSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRefPolicy(obj: RecordSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRef
 */
export interface RecordSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj: RecordSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordSpecPublishConnectionDetailsToMetadata
 */
export interface RecordSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToMetadata(obj: RecordSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordSpecForProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeoproximityRoutingPolicyCoordinates(obj: RecordSpecForProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicy
 */
export interface RecordSpecForProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj: RecordSpecForProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy
 */
export interface RecordSpecForProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj: RecordSpecForProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicy
 */
export interface RecordSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRefPolicy(obj: RecordSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicy
 */
export interface RecordSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj: RecordSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates(obj: RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicy
 */
export interface RecordSpecInitProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdRefPolicy(obj: RecordSpecInitProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy
 */
export interface RecordSpecInitProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdSelectorPolicy(obj: RecordSpecInitProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicy
 */
export interface RecordSpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdRefPolicy(obj: RecordSpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicy
 */
export interface RecordSpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdSelectorPolicy(obj: RecordSpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolution
 */
export enum RecordSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolve
 */
export enum RecordSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolution
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolve
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordSpecInitProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordSpecInitProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicyResolution
 */
export enum RecordSpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicyResolve
 */
export enum RecordSpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum RecordSpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum RecordSpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema RecordV1Beta2
 */
export class Route53RecordV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecordV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta2',
    kind: 'Record',
  }

  /**
   * Renders a Kubernetes manifest for "RecordV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53RecordV1Beta2Props): any {
    return {
      ...Route53RecordV1Beta2.GVK,
      ...toJson_Route53RecordV1Beta2Props(props),
    };
  }

  /**
   * Defines a "RecordV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53RecordV1Beta2Props) {
    super(scope, id, {
      ...Route53RecordV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53RecordV1Beta2.GVK,
      ...toJson_Route53RecordV1Beta2Props(resolved),
    };
  }
}

/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema RecordV1Beta2
 */
export interface Route53RecordV1Beta2Props {
  /**
   * @schema RecordV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSpec defines the desired state of Record
   *
   * @schema RecordV1Beta2#spec
   */
  readonly spec: RecordV1Beta2Spec;

}

/**
 * Converts an object of type 'Route53RecordV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53RecordV1Beta2Props(obj: Route53RecordV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSpec defines the desired state of Record
 *
 * @schema RecordV1Beta2Spec
 */
export interface RecordV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: RecordV1Beta2SpecDeletionPolicy;

  /**
   * @schema RecordV1Beta2Spec#forProvider
   */
  readonly forProvider: RecordV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordV1Beta2Spec#initProvider
   */
  readonly initProvider?: RecordV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: RecordV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: RecordV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema RecordV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2Spec(obj: RecordV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RecordV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordV1Beta2SpecDeletionPolicy
 */
export enum RecordV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordV1Beta2SpecForProvider
 */
export interface RecordV1Beta2SpecForProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#alias
   */
  readonly alias?: RecordV1Beta2SpecForProviderAlias;

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordV1Beta2SpecForProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordV1Beta2SpecForProviderCidrRoutingPolicy;

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordV1Beta2SpecForProviderFailoverRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordV1Beta2SpecForProviderGeolocationRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy;

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordV1Beta2SpecForProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordV1Beta2SpecForProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: RecordV1Beta2SpecForProviderLatencyRoutingPolicy;

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordV1Beta2SpecForProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecForProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordV1Beta2SpecForProvider#records
   */
  readonly records?: string[];

  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RecordV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordV1Beta2SpecForProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordV1Beta2SpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecForProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordV1Beta2SpecForProviderWeightedRoutingPolicy;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordV1Beta2SpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordV1Beta2SpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProvider(obj: RecordV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': toJson_RecordV1Beta2SpecForProviderAlias(obj.alias),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': toJson_RecordV1Beta2SpecForProviderCidrRoutingPolicy(obj.cidrRoutingPolicy),
    'failoverRoutingPolicy': toJson_RecordV1Beta2SpecForProviderFailoverRoutingPolicy(obj.failoverRoutingPolicy),
    'geolocationRoutingPolicy': toJson_RecordV1Beta2SpecForProviderGeolocationRoutingPolicy(obj.geolocationRoutingPolicy),
    'geoproximityRoutingPolicy': toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy(obj.geoproximityRoutingPolicy),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordV1Beta2SpecForProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': toJson_RecordV1Beta2SpecForProviderLatencyRoutingPolicy(obj.latencyRoutingPolicy),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'region': obj.region,
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': toJson_RecordV1Beta2SpecForProviderWeightedRoutingPolicy(obj.weightedRoutingPolicy),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordV1Beta2SpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordV1Beta2SpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordV1Beta2SpecInitProvider
 */
export interface RecordV1Beta2SpecInitProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#alias
   */
  readonly alias?: RecordV1Beta2SpecInitProviderAlias;

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordV1Beta2SpecInitProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordV1Beta2SpecInitProviderCidrRoutingPolicy;

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordV1Beta2SpecInitProviderFailoverRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy;

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordV1Beta2SpecInitProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordV1Beta2SpecInitProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: any;

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordV1Beta2SpecInitProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordV1Beta2SpecInitProvider#records
   */
  readonly records?: string[];

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordV1Beta2SpecInitProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordV1Beta2SpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecInitProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordV1Beta2SpecInitProviderWeightedRoutingPolicy;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordV1Beta2SpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordV1Beta2SpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProvider(obj: RecordV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': toJson_RecordV1Beta2SpecInitProviderAlias(obj.alias),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderCidrRoutingPolicy(obj.cidrRoutingPolicy),
    'failoverRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderFailoverRoutingPolicy(obj.failoverRoutingPolicy),
    'geolocationRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy(obj.geolocationRoutingPolicy),
    'geoproximityRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy(obj.geoproximityRoutingPolicy),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy,
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderWeightedRoutingPolicy(obj.weightedRoutingPolicy),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordV1Beta2SpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordV1Beta2SpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordV1Beta2SpecManagementPolicies
 */
export enum RecordV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordV1Beta2SpecProviderConfigRef
 */
export interface RecordV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: RecordV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecProviderConfigRef(obj: RecordV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsTo
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsTo(obj: RecordV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema RecordV1Beta2SpecWriteConnectionSecretToRef
 */
export interface RecordV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecWriteConnectionSecretToRef(obj: RecordV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An alias block. Conflicts with ttl & records.
 * Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderAlias
 */
export interface RecordV1Beta2SpecForProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderAlias(obj: RecordV1Beta2SpecForProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderCidrRoutingPolicy(obj: RecordV1Beta2SpecForProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderFailoverRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecForProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderFailoverRoutingPolicy(obj: RecordV1Beta2SpecForProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeolocationRoutingPolicy(obj: RecordV1Beta2SpecForProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy(obj: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdRef(obj: RecordV1Beta2SpecForProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelector(obj: RecordV1Beta2SpecForProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderLatencyRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderLatencyRoutingPolicy {
  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   *
   * @schema RecordV1Beta2SpecForProviderLatencyRoutingPolicy#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderLatencyRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderLatencyRoutingPolicy(obj: RecordV1Beta2SpecForProviderLatencyRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderWeightedRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordV1Beta2SpecForProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderWeightedRoutingPolicy(obj: RecordV1Beta2SpecForProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRef
 */
export interface RecordV1Beta2SpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdRef(obj: RecordV1Beta2SpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelector
 */
export interface RecordV1Beta2SpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdSelector(obj: RecordV1Beta2SpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An alias block. Conflicts with ttl & records.
 * Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderAlias
 */
export interface RecordV1Beta2SpecInitProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderAlias(obj: RecordV1Beta2SpecInitProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderCidrRoutingPolicy(obj: RecordV1Beta2SpecInitProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderFailoverRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecInitProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderFailoverRoutingPolicy(obj: RecordV1Beta2SpecInitProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy(obj: RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy(obj: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRef(obj: RecordV1Beta2SpecInitProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelector(obj: RecordV1Beta2SpecInitProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderWeightedRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordV1Beta2SpecInitProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderWeightedRoutingPolicy(obj: RecordV1Beta2SpecInitProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRef
 */
export interface RecordV1Beta2SpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdRef(obj: RecordV1Beta2SpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelector
 */
export interface RecordV1Beta2SpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdSelector(obj: RecordV1Beta2SpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicy
 */
export interface RecordV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecProviderConfigRefPolicy(obj: RecordV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: RecordV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToMetadata(obj: RecordV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates(obj: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy(obj: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy(obj: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy
 */
export interface RecordV1Beta2SpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdRefPolicy(obj: RecordV1Beta2SpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy
 */
export interface RecordV1Beta2SpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdSelectorPolicy(obj: RecordV1Beta2SpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates(obj: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy(obj: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy(obj: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy
 */
export interface RecordV1Beta2SpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdRefPolicy(obj: RecordV1Beta2SpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy
 */
export interface RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy(obj: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum RecordV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum RecordV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

