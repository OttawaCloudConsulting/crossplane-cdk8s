// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * DelegationSet is the Schema for the DelegationSets API. Provides a Route53 Delegation Set resource.
 *
 * @schema DelegationSet
 */
export class Route53DelegationSet extends ApiObject {
  /**
   * Returns the apiVersion and kind for "DelegationSet"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'DelegationSet',
  }

  /**
   * Renders a Kubernetes manifest for "DelegationSet".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53DelegationSetProps): any {
    return {
      ...Route53DelegationSet.GVK,
      ...toJson_Route53DelegationSetProps(props),
    };
  }

  /**
   * Defines a "DelegationSet" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53DelegationSetProps) {
    super(scope, id, {
      ...Route53DelegationSet.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53DelegationSet.GVK,
      ...toJson_Route53DelegationSetProps(resolved),
    };
  }
}

/**
 * DelegationSet is the Schema for the DelegationSets API. Provides a Route53 Delegation Set resource.
 *
 * @schema DelegationSet
 */
export interface Route53DelegationSetProps {
  /**
   * @schema DelegationSet#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * DelegationSetSpec defines the desired state of DelegationSet
   *
   * @schema DelegationSet#spec
   */
  readonly spec: DelegationSetSpec;

}

/**
 * Converts an object of type 'Route53DelegationSetProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53DelegationSetProps(obj: Route53DelegationSetProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_DelegationSetSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DelegationSetSpec defines the desired state of DelegationSet
 *
 * @schema DelegationSetSpec
 */
export interface DelegationSetSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema DelegationSetSpec#deletionPolicy
   */
  readonly deletionPolicy?: DelegationSetSpecDeletionPolicy;

  /**
   * @schema DelegationSetSpec#forProvider
   */
  readonly forProvider: DelegationSetSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema DelegationSetSpec#initProvider
   */
  readonly initProvider?: DelegationSetSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema DelegationSetSpec#managementPolicies
   */
  readonly managementPolicies?: DelegationSetSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema DelegationSetSpec#providerConfigRef
   */
  readonly providerConfigRef?: DelegationSetSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema DelegationSetSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: DelegationSetSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema DelegationSetSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: DelegationSetSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'DelegationSetSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpec(obj: DelegationSetSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_DelegationSetSpecForProvider(obj.forProvider),
    'initProvider': toJson_DelegationSetSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_DelegationSetSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_DelegationSetSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_DelegationSetSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema DelegationSetSpecDeletionPolicy
 */
export enum DelegationSetSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema DelegationSetSpecForProvider
 */
export interface DelegationSetSpecForProvider {
  /**
   * This is a reference name used in Caller Reference
   * (helpful for identifying single delegation set amongst others)
   *
   * @schema DelegationSetSpecForProvider#referenceName
   */
  readonly referenceName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema DelegationSetSpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'DelegationSetSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecForProvider(obj: DelegationSetSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceName': obj.referenceName,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema DelegationSetSpecInitProvider
 */
export interface DelegationSetSpecInitProvider {
  /**
   * This is a reference name used in Caller Reference
   * (helpful for identifying single delegation set amongst others)
   *
   * @schema DelegationSetSpecInitProvider#referenceName
   */
  readonly referenceName?: string;

}

/**
 * Converts an object of type 'DelegationSetSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecInitProvider(obj: DelegationSetSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'referenceName': obj.referenceName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema DelegationSetSpecManagementPolicies
 */
export enum DelegationSetSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema DelegationSetSpecProviderConfigRef
 */
export interface DelegationSetSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegationSetSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegationSetSpecProviderConfigRef#policy
   */
  readonly policy?: DelegationSetSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderConfigRef(obj: DelegationSetSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegationSetSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsTo
 */
export interface DelegationSetSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: DelegationSetSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: DelegationSetSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsTo(obj: DelegationSetSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_DelegationSetSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_DelegationSetSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema DelegationSetSpecWriteConnectionSecretToRef
 */
export interface DelegationSetSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema DelegationSetSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema DelegationSetSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'DelegationSetSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecWriteConnectionSecretToRef(obj: DelegationSetSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicy
 */
export interface DelegationSetSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema DelegationSetSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: DelegationSetSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema DelegationSetSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: DelegationSetSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegationSetSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecProviderConfigRefPolicy(obj: DelegationSetSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef
 */
export interface DelegationSetSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToConfigRef(obj: DelegationSetSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToMetadata
 */
export interface DelegationSetSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToMetadata(obj: DelegationSetSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicyResolution
 */
export enum DelegationSetSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema DelegationSetSpecProviderConfigRefPolicyResolve
 */
export enum DelegationSetSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy(obj: DelegationSetSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum DelegationSetSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HealthCheck is the Schema for the HealthChecks API. Provides a Route53 health check.
 *
 * @schema HealthCheck
 */
export class Route53HealthCheck extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HealthCheck"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'HealthCheck',
  }

  /**
   * Renders a Kubernetes manifest for "HealthCheck".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53HealthCheckProps): any {
    return {
      ...Route53HealthCheck.GVK,
      ...toJson_Route53HealthCheckProps(props),
    };
  }

  /**
   * Defines a "HealthCheck" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53HealthCheckProps) {
    super(scope, id, {
      ...Route53HealthCheck.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53HealthCheck.GVK,
      ...toJson_Route53HealthCheckProps(resolved),
    };
  }
}

/**
 * HealthCheck is the Schema for the HealthChecks API. Provides a Route53 health check.
 *
 * @schema HealthCheck
 */
export interface Route53HealthCheckProps {
  /**
   * @schema HealthCheck#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HealthCheckSpec defines the desired state of HealthCheck
   *
   * @schema HealthCheck#spec
   */
  readonly spec: HealthCheckSpec;

}

/**
 * Converts an object of type 'Route53HealthCheckProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53HealthCheckProps(obj: Route53HealthCheckProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HealthCheckSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HealthCheckSpec defines the desired state of HealthCheck
 *
 * @schema HealthCheckSpec
 */
export interface HealthCheckSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HealthCheckSpec#deletionPolicy
   */
  readonly deletionPolicy?: HealthCheckSpecDeletionPolicy;

  /**
   * @schema HealthCheckSpec#forProvider
   */
  readonly forProvider: HealthCheckSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema HealthCheckSpec#initProvider
   */
  readonly initProvider?: HealthCheckSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HealthCheckSpec#managementPolicies
   */
  readonly managementPolicies?: HealthCheckSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema HealthCheckSpec#providerConfigRef
   */
  readonly providerConfigRef?: HealthCheckSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema HealthCheckSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HealthCheckSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema HealthCheckSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HealthCheckSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HealthCheckSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpec(obj: HealthCheckSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HealthCheckSpecForProvider(obj.forProvider),
    'initProvider': toJson_HealthCheckSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HealthCheckSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HealthCheckSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HealthCheckSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HealthCheckSpecDeletionPolicy
 */
export enum HealthCheckSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HealthCheckSpecForProvider
 */
export interface HealthCheckSpecForProvider {
  /**
   * The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
   *
   * @schema HealthCheckSpecForProvider#childHealthThreshold
   */
  readonly childHealthThreshold?: number;

  /**
   * For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
   *
   * @schema HealthCheckSpecForProvider#childHealthchecks
   */
  readonly childHealthchecks?: string[];

  /**
   * The name of the CloudWatch alarm.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmName
   */
  readonly cloudwatchAlarmName?: string;

  /**
   * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmNameRef
   */
  readonly cloudwatchAlarmNameRef?: HealthCheckSpecForProviderCloudwatchAlarmNameRef;

  /**
   * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmNameSelector
   */
  readonly cloudwatchAlarmNameSelector?: HealthCheckSpecForProviderCloudwatchAlarmNameSelector;

  /**
   * The CloudWatchRegion that the CloudWatch alarm was created in.
   *
   * @schema HealthCheckSpecForProvider#cloudwatchAlarmRegion
   */
  readonly cloudwatchAlarmRegion?: string;

  /**
   * A boolean value that stops Route 53 from performing health checks. When set to true, Route 53 will do the following depending on the type of health check:
   *
   * @schema HealthCheckSpecForProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * A boolean value that indicates whether Route53 should send the fqdn to the endpoint when performing the health check. This defaults to AWS' defaults: when the type is "HTTPS" enable_sni defaults to true, when type is anything else enable_sni defaults to false.
   *
   * @schema HealthCheckSpecForProvider#enableSni
   */
  readonly enableSni?: boolean;

  /**
   * The number of consecutive health checks that an endpoint must pass or fail.
   *
   * @schema HealthCheckSpecForProvider#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The fully qualified domain name of the endpoint to be checked. If a value is set for ip_address, the value set for fqdn will be passed in the Host header.
   *
   * @schema HealthCheckSpecForProvider#fqdn
   */
  readonly fqdn?: string;

  /**
   * The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are Healthy , Unhealthy and LastKnownStatus.
   *
   * @schema HealthCheckSpecForProvider#insufficientDataHealthStatus
   */
  readonly insufficientDataHealthStatus?: string;

  /**
   * A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
   *
   * @schema HealthCheckSpecForProvider#invertHealthcheck
   */
  readonly invertHealthcheck?: boolean;

  /**
   * The IP address of the endpoint to be checked.
   *
   * @schema HealthCheckSpecForProvider#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
   *
   * @schema HealthCheckSpecForProvider#measureLatency
   */
  readonly measureLatency?: boolean;

  /**
   * The port of the endpoint to be checked.
   *
   * @schema HealthCheckSpecForProvider#port
   */
  readonly port?: number;

  /**
   * This is a reference name used in Caller Reference
   * (helpful for identifying single health_check set amongst others)
   *
   * @schema HealthCheckSpecForProvider#referenceName
   */
  readonly referenceName?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HealthCheckSpecForProvider#region
   */
  readonly region: string;

  /**
   * A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
   *
   * @schema HealthCheckSpecForProvider#regions
   */
  readonly regions?: string[];

  /**
   * The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
   *
   * @schema HealthCheckSpecForProvider#requestInterval
   */
  readonly requestInterval?: number;

  /**
   * The path that you want Amazon Route 53 to request when performing health checks.
   *
   * @schema HealthCheckSpecForProvider#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control. This is used when health check type is RECOVERY_CONTROL
   *
   * @schema HealthCheckSpecForProvider#routingControlArn
   */
  readonly routingControlArn?: string;

  /**
   * String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with HTTP_STR_MATCH and HTTPS_STR_MATCH.
   *
   * @schema HealthCheckSpecForProvider#searchString
   */
  readonly searchString?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HealthCheckSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The protocol to use when performing health checks. Valid values are HTTP, HTTPS, HTTP_STR_MATCH, HTTPS_STR_MATCH, TCP, CALCULATED, CLOUDWATCH_METRIC and RECOVERY_CONTROL.
   *
   * @schema HealthCheckSpecForProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HealthCheckSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProvider(obj: HealthCheckSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'childHealthThreshold': obj.childHealthThreshold,
    'childHealthchecks': obj.childHealthchecks?.map(y => y),
    'cloudwatchAlarmName': obj.cloudwatchAlarmName,
    'cloudwatchAlarmNameRef': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRef(obj.cloudwatchAlarmNameRef),
    'cloudwatchAlarmNameSelector': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelector(obj.cloudwatchAlarmNameSelector),
    'cloudwatchAlarmRegion': obj.cloudwatchAlarmRegion,
    'disabled': obj.disabled,
    'enableSni': obj.enableSni,
    'failureThreshold': obj.failureThreshold,
    'fqdn': obj.fqdn,
    'insufficientDataHealthStatus': obj.insufficientDataHealthStatus,
    'invertHealthcheck': obj.invertHealthcheck,
    'ipAddress': obj.ipAddress,
    'measureLatency': obj.measureLatency,
    'port': obj.port,
    'referenceName': obj.referenceName,
    'region': obj.region,
    'regions': obj.regions?.map(y => y),
    'requestInterval': obj.requestInterval,
    'resourcePath': obj.resourcePath,
    'routingControlArn': obj.routingControlArn,
    'searchString': obj.searchString,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema HealthCheckSpecInitProvider
 */
export interface HealthCheckSpecInitProvider {
  /**
   * The minimum number of child health checks that must be healthy for Route 53 to consider the parent health check to be healthy. Valid values are integers between 0 and 256, inclusive
   *
   * @schema HealthCheckSpecInitProvider#childHealthThreshold
   */
  readonly childHealthThreshold?: number;

  /**
   * For a specified parent health check, a list of HealthCheckId values for the associated child health checks.
   *
   * @schema HealthCheckSpecInitProvider#childHealthchecks
   */
  readonly childHealthchecks?: string[];

  /**
   * The name of the CloudWatch alarm.
   *
   * @schema HealthCheckSpecInitProvider#cloudwatchAlarmName
   */
  readonly cloudwatchAlarmName?: string;

  /**
   * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecInitProvider#cloudwatchAlarmNameRef
   */
  readonly cloudwatchAlarmNameRef?: HealthCheckSpecInitProviderCloudwatchAlarmNameRef;

  /**
   * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
   *
   * @schema HealthCheckSpecInitProvider#cloudwatchAlarmNameSelector
   */
  readonly cloudwatchAlarmNameSelector?: HealthCheckSpecInitProviderCloudwatchAlarmNameSelector;

  /**
   * The CloudWatchRegion that the CloudWatch alarm was created in.
   *
   * @schema HealthCheckSpecInitProvider#cloudwatchAlarmRegion
   */
  readonly cloudwatchAlarmRegion?: string;

  /**
   * A boolean value that stops Route 53 from performing health checks. When set to true, Route 53 will do the following depending on the type of health check:
   *
   * @schema HealthCheckSpecInitProvider#disabled
   */
  readonly disabled?: boolean;

  /**
   * A boolean value that indicates whether Route53 should send the fqdn to the endpoint when performing the health check. This defaults to AWS' defaults: when the type is "HTTPS" enable_sni defaults to true, when type is anything else enable_sni defaults to false.
   *
   * @schema HealthCheckSpecInitProvider#enableSni
   */
  readonly enableSni?: boolean;

  /**
   * The number of consecutive health checks that an endpoint must pass or fail.
   *
   * @schema HealthCheckSpecInitProvider#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The fully qualified domain name of the endpoint to be checked. If a value is set for ip_address, the value set for fqdn will be passed in the Host header.
   *
   * @schema HealthCheckSpecInitProvider#fqdn
   */
  readonly fqdn?: string;

  /**
   * The status of the health check when CloudWatch has insufficient data about the state of associated alarm. Valid values are Healthy , Unhealthy and LastKnownStatus.
   *
   * @schema HealthCheckSpecInitProvider#insufficientDataHealthStatus
   */
  readonly insufficientDataHealthStatus?: string;

  /**
   * A boolean value that indicates whether the status of health check should be inverted. For example, if a health check is healthy but Inverted is True , then Route 53 considers the health check to be unhealthy.
   *
   * @schema HealthCheckSpecInitProvider#invertHealthcheck
   */
  readonly invertHealthcheck?: boolean;

  /**
   * The IP address of the endpoint to be checked.
   *
   * @schema HealthCheckSpecInitProvider#ipAddress
   */
  readonly ipAddress?: string;

  /**
   * A Boolean value that indicates whether you want Route 53 to measure the latency between health checkers in multiple AWS regions and your endpoint and to display CloudWatch latency graphs in the Route 53 console.
   *
   * @schema HealthCheckSpecInitProvider#measureLatency
   */
  readonly measureLatency?: boolean;

  /**
   * The port of the endpoint to be checked.
   *
   * @schema HealthCheckSpecInitProvider#port
   */
  readonly port?: number;

  /**
   * This is a reference name used in Caller Reference
   * (helpful for identifying single health_check set amongst others)
   *
   * @schema HealthCheckSpecInitProvider#referenceName
   */
  readonly referenceName?: string;

  /**
   * A list of AWS regions that you want Amazon Route 53 health checkers to check the specified endpoint from.
   *
   * @schema HealthCheckSpecInitProvider#regions
   */
  readonly regions?: string[];

  /**
   * The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.
   *
   * @schema HealthCheckSpecInitProvider#requestInterval
   */
  readonly requestInterval?: number;

  /**
   * The path that you want Amazon Route 53 to request when performing health checks.
   *
   * @schema HealthCheckSpecInitProvider#resourcePath
   */
  readonly resourcePath?: string;

  /**
   * The Amazon Resource Name (ARN) for the Route 53 Application Recovery Controller routing control. This is used when health check type is RECOVERY_CONTROL
   *
   * @schema HealthCheckSpecInitProvider#routingControlArn
   */
  readonly routingControlArn?: string;

  /**
   * String searched in the first 5120 bytes of the response body for check to be considered healthy. Only valid with HTTP_STR_MATCH and HTTPS_STR_MATCH.
   *
   * @schema HealthCheckSpecInitProvider#searchString
   */
  readonly searchString?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema HealthCheckSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * The protocol to use when performing health checks. Valid values are HTTP, HTTPS, HTTP_STR_MATCH, HTTPS_STR_MATCH, TCP, CALCULATED, CLOUDWATCH_METRIC and RECOVERY_CONTROL.
   *
   * @schema HealthCheckSpecInitProvider#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HealthCheckSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecInitProvider(obj: HealthCheckSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'childHealthThreshold': obj.childHealthThreshold,
    'childHealthchecks': obj.childHealthchecks?.map(y => y),
    'cloudwatchAlarmName': obj.cloudwatchAlarmName,
    'cloudwatchAlarmNameRef': toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameRef(obj.cloudwatchAlarmNameRef),
    'cloudwatchAlarmNameSelector': toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameSelector(obj.cloudwatchAlarmNameSelector),
    'cloudwatchAlarmRegion': obj.cloudwatchAlarmRegion,
    'disabled': obj.disabled,
    'enableSni': obj.enableSni,
    'failureThreshold': obj.failureThreshold,
    'fqdn': obj.fqdn,
    'insufficientDataHealthStatus': obj.insufficientDataHealthStatus,
    'invertHealthcheck': obj.invertHealthcheck,
    'ipAddress': obj.ipAddress,
    'measureLatency': obj.measureLatency,
    'port': obj.port,
    'referenceName': obj.referenceName,
    'regions': obj.regions?.map(y => y),
    'requestInterval': obj.requestInterval,
    'resourcePath': obj.resourcePath,
    'routingControlArn': obj.routingControlArn,
    'searchString': obj.searchString,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema HealthCheckSpecManagementPolicies
 */
export enum HealthCheckSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema HealthCheckSpecProviderConfigRef
 */
export interface HealthCheckSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecProviderConfigRef#policy
   */
  readonly policy?: HealthCheckSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderConfigRef(obj: HealthCheckSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsTo
 */
export interface HealthCheckSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HealthCheckSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HealthCheckSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsTo(obj: HealthCheckSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HealthCheckSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HealthCheckSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema HealthCheckSpecWriteConnectionSecretToRef
 */
export interface HealthCheckSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HealthCheckSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HealthCheckSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HealthCheckSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecWriteConnectionSecretToRef(obj: HealthCheckSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRef#policy
   */
  readonly policy?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRef(obj: HealthCheckSpecForProviderCloudwatchAlarmNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelector#policy
   */
  readonly policy?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelector(obj: HealthCheckSpecForProviderCloudwatchAlarmNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRef
 */
export interface HealthCheckSpecInitProviderCloudwatchAlarmNameRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRef#policy
   */
  readonly policy?: HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecInitProviderCloudwatchAlarmNameRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameRef(obj: HealthCheckSpecInitProviderCloudwatchAlarmNameRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a MetricAlarm in cloudwatch to populate cloudwatchAlarmName.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelector
 */
export interface HealthCheckSpecInitProviderCloudwatchAlarmNameSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelector#policy
   */
  readonly policy?: HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecInitProviderCloudwatchAlarmNameSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameSelector(obj: HealthCheckSpecInitProviderCloudwatchAlarmNameSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicy
 */
export interface HealthCheckSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecProviderConfigRefPolicy(obj: HealthCheckSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef
 */
export interface HealthCheckSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToConfigRef(obj: HealthCheckSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToMetadata
 */
export interface HealthCheckSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToMetadata(obj: HealthCheckSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy(obj: HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy
 */
export interface HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy(obj: HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy
 */
export interface HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy(obj: HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy
 */
export interface HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy(obj: HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicyResolution
 */
export enum HealthCheckSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecProviderConfigRefPolicyResolve
 */
export enum HealthCheckSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy(obj: HealthCheckSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve
 */
export enum HealthCheckSpecForProviderCloudwatchAlarmNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolution
 */
export enum HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolve
 */
export enum HealthCheckSpecInitProviderCloudwatchAlarmNameRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolution
 */
export enum HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolve
 */
export enum HealthCheckSpecInitProviderCloudwatchAlarmNameSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HealthCheckSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * HostedZoneDNSSEC is the Schema for the HostedZoneDNSSECs API. Manages Route 53 Hosted Zone DNSSEC
 *
 * @schema HostedZoneDNSSEC
 */
export class Route53HostedZoneDnssec extends ApiObject {
  /**
   * Returns the apiVersion and kind for "HostedZoneDNSSEC"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'HostedZoneDNSSEC',
  }

  /**
   * Renders a Kubernetes manifest for "HostedZoneDNSSEC".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53HostedZoneDnssecProps): any {
    return {
      ...Route53HostedZoneDnssec.GVK,
      ...toJson_Route53HostedZoneDnssecProps(props),
    };
  }

  /**
   * Defines a "HostedZoneDNSSEC" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53HostedZoneDnssecProps) {
    super(scope, id, {
      ...Route53HostedZoneDnssec.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53HostedZoneDnssec.GVK,
      ...toJson_Route53HostedZoneDnssecProps(resolved),
    };
  }
}

/**
 * HostedZoneDNSSEC is the Schema for the HostedZoneDNSSECs API. Manages Route 53 Hosted Zone DNSSEC
 *
 * @schema HostedZoneDNSSEC
 */
export interface Route53HostedZoneDnssecProps {
  /**
   * @schema HostedZoneDNSSEC#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * HostedZoneDNSSECSpec defines the desired state of HostedZoneDNSSEC
   *
   * @schema HostedZoneDNSSEC#spec
   */
  readonly spec: HostedZoneDnssecSpec;

}

/**
 * Converts an object of type 'Route53HostedZoneDnssecProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53HostedZoneDnssecProps(obj: Route53HostedZoneDnssecProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_HostedZoneDnssecSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HostedZoneDNSSECSpec defines the desired state of HostedZoneDNSSEC
 *
 * @schema HostedZoneDnssecSpec
 */
export interface HostedZoneDnssecSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema HostedZoneDnssecSpec#deletionPolicy
   */
  readonly deletionPolicy?: HostedZoneDnssecSpecDeletionPolicy;

  /**
   * @schema HostedZoneDnssecSpec#forProvider
   */
  readonly forProvider: HostedZoneDnssecSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema HostedZoneDnssecSpec#initProvider
   */
  readonly initProvider?: HostedZoneDnssecSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema HostedZoneDnssecSpec#managementPolicies
   */
  readonly managementPolicies?: HostedZoneDnssecSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema HostedZoneDnssecSpec#providerConfigRef
   */
  readonly providerConfigRef?: HostedZoneDnssecSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema HostedZoneDnssecSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: HostedZoneDnssecSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema HostedZoneDnssecSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: HostedZoneDnssecSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpec(obj: HostedZoneDnssecSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_HostedZoneDnssecSpecForProvider(obj.forProvider),
    'initProvider': toJson_HostedZoneDnssecSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_HostedZoneDnssecSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_HostedZoneDnssecSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_HostedZoneDnssecSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema HostedZoneDnssecSpecDeletionPolicy
 */
export enum HostedZoneDnssecSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema HostedZoneDnssecSpecForProvider
 */
export interface HostedZoneDnssecSpecForProvider {
  /**
   * Identifier of the Route 53 Hosted Zone.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone in route53 to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: HostedZoneDnssecSpecForProviderHostedZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecForProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: HostedZoneDnssecSpecForProviderHostedZoneIdSelector;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema HostedZoneDnssecSpecForProvider#region
   */
  readonly region: string;

  /**
   * Hosted Zone signing status. Valid values: SIGNING, NOT_SIGNING. Defaults to SIGNING.
   *
   * @default SIGNING.
   * @schema HostedZoneDnssecSpecForProvider#signingStatus
   */
  readonly signingStatus?: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProvider(obj: HostedZoneDnssecSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'region': obj.region,
    'signingStatus': obj.signingStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema HostedZoneDnssecSpecInitProvider
 */
export interface HostedZoneDnssecSpecInitProvider {
  /**
   * Identifier of the Route 53 Hosted Zone.
   *
   * @schema HostedZoneDnssecSpecInitProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone in route53 to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecInitProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: HostedZoneDnssecSpecInitProviderHostedZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate hostedZoneId.
   *
   * @schema HostedZoneDnssecSpecInitProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: HostedZoneDnssecSpecInitProviderHostedZoneIdSelector;

  /**
   * Hosted Zone signing status. Valid values: SIGNING, NOT_SIGNING. Defaults to SIGNING.
   *
   * @default SIGNING.
   * @schema HostedZoneDnssecSpecInitProvider#signingStatus
   */
  readonly signingStatus?: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecInitProvider(obj: HostedZoneDnssecSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'signingStatus': obj.signingStatus,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema HostedZoneDnssecSpecManagementPolicies
 */
export enum HostedZoneDnssecSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRef
 */
export interface HostedZoneDnssecSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderConfigRef(obj: HostedZoneDnssecSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: HostedZoneDnssecSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsTo(obj: HostedZoneDnssecSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef
 */
export interface HostedZoneDnssecSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema HostedZoneDnssecSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecWriteConnectionSecretToRef(obj: HostedZoneDnssecSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRef(obj: HostedZoneDnssecSpecForProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelector#policy
   */
  readonly policy?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelector(obj: HostedZoneDnssecSpecForProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRef
 */
export interface HostedZoneDnssecSpecInitProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecInitProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdRef(obj: HostedZoneDnssecSpecInitProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate hostedZoneId.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelector
 */
export interface HostedZoneDnssecSpecInitProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelector#policy
   */
  readonly policy?: HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecInitProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdSelector(obj: HostedZoneDnssecSpecInitProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicy
 */
export interface HostedZoneDnssecSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecProviderConfigRefPolicy(obj: HostedZoneDnssecSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef(obj: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToMetadata(obj: HostedZoneDnssecSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy(obj: HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy
 */
export interface HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy(obj: HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy
 */
export interface HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy(obj: HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy
 */
export interface HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy(obj: HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicyResolution
 */
export enum HostedZoneDnssecSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecProviderConfigRefPolicyResolve
 */
export enum HostedZoneDnssecSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy(obj: HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve
 */
export enum HostedZoneDnssecSpecForProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolution
 */
export enum HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolve
 */
export enum HostedZoneDnssecSpecInitProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolution
 */
export enum HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolve
 */
export enum HostedZoneDnssecSpecInitProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum HostedZoneDnssecSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export class Route53Record extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Record"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'Record',
  }

  /**
   * Renders a Kubernetes manifest for "Record".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53RecordProps): any {
    return {
      ...Route53Record.GVK,
      ...toJson_Route53RecordProps(props),
    };
  }

  /**
   * Defines a "Record" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53RecordProps) {
    super(scope, id, {
      ...Route53Record.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53Record.GVK,
      ...toJson_Route53RecordProps(resolved),
    };
  }
}

/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema Record
 */
export interface Route53RecordProps {
  /**
   * @schema Record#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSpec defines the desired state of Record
   *
   * @schema Record#spec
   */
  readonly spec: RecordSpec;

}

/**
 * Converts an object of type 'Route53RecordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53RecordProps(obj: Route53RecordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSpec defines the desired state of Record
 *
 * @schema RecordSpec
 */
export interface RecordSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordSpec#deletionPolicy
   */
  readonly deletionPolicy?: RecordSpecDeletionPolicy;

  /**
   * @schema RecordSpec#forProvider
   */
  readonly forProvider: RecordSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordSpec#initProvider
   */
  readonly initProvider?: RecordSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordSpec#managementPolicies
   */
  readonly managementPolicies?: RecordSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordSpec#providerConfigRef
   */
  readonly providerConfigRef?: RecordSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema RecordSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpec(obj: RecordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordSpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RecordSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordSpecDeletionPolicy
 */
export enum RecordSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordSpecForProvider
 */
export interface RecordSpecForProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordSpecForProvider#alias
   */
  readonly alias?: RecordSpecForProviderAlias[];

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordSpecForProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordSpecForProviderCidrRoutingPolicy[];

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordSpecForProviderFailoverRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordSpecForProviderGeolocationRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordSpecForProviderGeoproximityRoutingPolicy[];

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordSpecForProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordSpecForProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecForProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordSpecForProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: RecordSpecForProviderLatencyRoutingPolicy[];

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordSpecForProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordSpecForProvider#records
   */
  readonly records?: string[];

  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RecordSpecForProvider#region
   */
  readonly region: string;

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordSpecForProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordSpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecForProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordSpecForProviderWeightedRoutingPolicy[];

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProvider(obj: RecordSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias?.map(y => toJson_RecordSpecForProviderAlias(y)),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': obj.cidrRoutingPolicy?.map(y => toJson_RecordSpecForProviderCidrRoutingPolicy(y)),
    'failoverRoutingPolicy': obj.failoverRoutingPolicy?.map(y => toJson_RecordSpecForProviderFailoverRoutingPolicy(y)),
    'geolocationRoutingPolicy': obj.geolocationRoutingPolicy?.map(y => toJson_RecordSpecForProviderGeolocationRoutingPolicy(y)),
    'geoproximityRoutingPolicy': obj.geoproximityRoutingPolicy?.map(y => toJson_RecordSpecForProviderGeoproximityRoutingPolicy(y)),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordSpecForProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordSpecForProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy?.map(y => toJson_RecordSpecForProviderLatencyRoutingPolicy(y)),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'region': obj.region,
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': obj.weightedRoutingPolicy?.map(y => toJson_RecordSpecForProviderWeightedRoutingPolicy(y)),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordSpecInitProvider
 */
export interface RecordSpecInitProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordSpecInitProvider#alias
   */
  readonly alias?: RecordSpecInitProviderAlias[];

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordSpecInitProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordSpecInitProviderCidrRoutingPolicy[];

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordSpecInitProviderFailoverRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordSpecInitProviderGeolocationRoutingPolicy[];

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordSpecInitProviderGeoproximityRoutingPolicy[];

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordSpecInitProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecInitProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordSpecInitProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordSpecInitProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordSpecInitProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: any[];

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordSpecInitProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordSpecInitProvider#records
   */
  readonly records?: string[];

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordSpecInitProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordSpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecInitProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordSpecInitProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordSpecInitProviderWeightedRoutingPolicy[];

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordSpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordSpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordSpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProvider(obj: RecordSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias?.map(y => toJson_RecordSpecInitProviderAlias(y)),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': obj.cidrRoutingPolicy?.map(y => toJson_RecordSpecInitProviderCidrRoutingPolicy(y)),
    'failoverRoutingPolicy': obj.failoverRoutingPolicy?.map(y => toJson_RecordSpecInitProviderFailoverRoutingPolicy(y)),
    'geolocationRoutingPolicy': obj.geolocationRoutingPolicy?.map(y => toJson_RecordSpecInitProviderGeolocationRoutingPolicy(y)),
    'geoproximityRoutingPolicy': obj.geoproximityRoutingPolicy?.map(y => toJson_RecordSpecInitProviderGeoproximityRoutingPolicy(y)),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordSpecInitProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordSpecInitProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy?.map(y => y),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': obj.weightedRoutingPolicy?.map(y => toJson_RecordSpecInitProviderWeightedRoutingPolicy(y)),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordSpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordSpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordSpecManagementPolicies
 */
export enum RecordSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordSpecProviderConfigRef
 */
export interface RecordSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecProviderConfigRef#policy
   */
  readonly policy?: RecordSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRef(obj: RecordSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordSpecPublishConnectionDetailsTo
 */
export interface RecordSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsTo(obj: RecordSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema RecordSpecWriteConnectionSecretToRef
 */
export interface RecordSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecWriteConnectionSecretToRef(obj: RecordSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderAlias
 */
export interface RecordSpecForProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordSpecForProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecForProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecForProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderAlias(obj: RecordSpecForProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderCidrRoutingPolicy
 */
export interface RecordSpecForProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordSpecForProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderCidrRoutingPolicy(obj: RecordSpecForProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderFailoverRoutingPolicy
 */
export interface RecordSpecForProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecForProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderFailoverRoutingPolicy(obj: RecordSpecForProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeolocationRoutingPolicy
 */
export interface RecordSpecForProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordSpecForProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeolocationRoutingPolicy(obj: RecordSpecForProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeoproximityRoutingPolicy
 */
export interface RecordSpecForProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordSpecForProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordSpecForProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeoproximityRoutingPolicy(obj: RecordSpecForProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordSpecForProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdRef
 */
export interface RecordSpecForProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRef(obj: RecordSpecForProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelector
 */
export interface RecordSpecForProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelector(obj: RecordSpecForProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderLatencyRoutingPolicy
 */
export interface RecordSpecForProviderLatencyRoutingPolicy {
  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   *
   * @schema RecordSpecForProviderLatencyRoutingPolicy#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderLatencyRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderLatencyRoutingPolicy(obj: RecordSpecForProviderLatencyRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderWeightedRoutingPolicy
 */
export interface RecordSpecForProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordSpecForProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordSpecForProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderWeightedRoutingPolicy(obj: RecordSpecForProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdRef
 */
export interface RecordSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecForProviderZoneIdRef#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRef(obj: RecordSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecForProviderZoneIdSelector
 */
export interface RecordSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: RecordSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelector(obj: RecordSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderAlias
 */
export interface RecordSpecInitProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordSpecInitProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordSpecInitProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordSpecInitProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderAlias(obj: RecordSpecInitProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderCidrRoutingPolicy
 */
export interface RecordSpecInitProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordSpecInitProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordSpecInitProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderCidrRoutingPolicy(obj: RecordSpecInitProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderFailoverRoutingPolicy
 */
export interface RecordSpecInitProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordSpecInitProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderFailoverRoutingPolicy(obj: RecordSpecInitProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeolocationRoutingPolicy
 */
export interface RecordSpecInitProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordSpecInitProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeolocationRoutingPolicy(obj: RecordSpecInitProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeoproximityRoutingPolicy
 */
export interface RecordSpecInitProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeoproximityRoutingPolicy(obj: RecordSpecInitProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRef
 */
export interface RecordSpecInitProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordSpecInitProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdRef(obj: RecordSpecInitProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecInitProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelector
 */
export interface RecordSpecInitProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordSpecInitProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdSelector(obj: RecordSpecInitProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecInitProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderWeightedRoutingPolicy
 */
export interface RecordSpecInitProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordSpecInitProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordSpecInitProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderWeightedRoutingPolicy(obj: RecordSpecInitProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecInitProviderZoneIdRef
 */
export interface RecordSpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecInitProviderZoneIdRef#policy
   */
  readonly policy?: RecordSpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdRef(obj: RecordSpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordSpecInitProviderZoneIdSelector
 */
export interface RecordSpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordSpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: RecordSpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdSelector(obj: RecordSpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordSpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecProviderConfigRefPolicy
 */
export interface RecordSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecProviderConfigRefPolicy(obj: RecordSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRef
 */
export interface RecordSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRef(obj: RecordSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordSpecPublishConnectionDetailsToMetadata
 */
export interface RecordSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToMetadata(obj: RecordSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordSpecForProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordSpecForProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordSpecForProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderGeoproximityRoutingPolicyCoordinates(obj: RecordSpecForProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicy
 */
export interface RecordSpecForProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdRefPolicy(obj: RecordSpecForProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy
 */
export interface RecordSpecForProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderHealthCheckIdSelectorPolicy(obj: RecordSpecForProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicy
 */
export interface RecordSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdRefPolicy(obj: RecordSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicy
 */
export interface RecordSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecForProviderZoneIdSelectorPolicy(obj: RecordSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates(obj: RecordSpecInitProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicy
 */
export interface RecordSpecInitProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdRefPolicy(obj: RecordSpecInitProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy
 */
export interface RecordSpecInitProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderHealthCheckIdSelectorPolicy(obj: RecordSpecInitProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicy
 */
export interface RecordSpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdRefPolicy(obj: RecordSpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicy
 */
export interface RecordSpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordSpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordSpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecInitProviderZoneIdSelectorPolicy(obj: RecordSpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolution
 */
export enum RecordSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecProviderConfigRefPolicyResolve
 */
export enum RecordSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordSpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolution
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdRefPolicyResolve
 */
export enum RecordSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum RecordSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordSpecInitProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordSpecInitProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordSpecInitProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordSpecInitProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicyResolution
 */
export enum RecordSpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderZoneIdRefPolicyResolve
 */
export enum RecordSpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum RecordSpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum RecordSpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema RecordV1Beta2
 */
export class Route53RecordV1Beta2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "RecordV1Beta2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta2',
    kind: 'Record',
  }

  /**
   * Renders a Kubernetes manifest for "RecordV1Beta2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53RecordV1Beta2Props): any {
    return {
      ...Route53RecordV1Beta2.GVK,
      ...toJson_Route53RecordV1Beta2Props(props),
    };
  }

  /**
   * Defines a "RecordV1Beta2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53RecordV1Beta2Props) {
    super(scope, id, {
      ...Route53RecordV1Beta2.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53RecordV1Beta2.GVK,
      ...toJson_Route53RecordV1Beta2Props(resolved),
    };
  }
}

/**
 * Record is the Schema for the Records API. Provides a Route53 record resource.
 *
 * @schema RecordV1Beta2
 */
export interface Route53RecordV1Beta2Props {
  /**
   * @schema RecordV1Beta2#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * RecordSpec defines the desired state of Record
   *
   * @schema RecordV1Beta2#spec
   */
  readonly spec: RecordV1Beta2Spec;

}

/**
 * Converts an object of type 'Route53RecordV1Beta2Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53RecordV1Beta2Props(obj: Route53RecordV1Beta2Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_RecordV1Beta2Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RecordSpec defines the desired state of Record
 *
 * @schema RecordV1Beta2Spec
 */
export interface RecordV1Beta2Spec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema RecordV1Beta2Spec#deletionPolicy
   */
  readonly deletionPolicy?: RecordV1Beta2SpecDeletionPolicy;

  /**
   * @schema RecordV1Beta2Spec#forProvider
   */
  readonly forProvider: RecordV1Beta2SpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema RecordV1Beta2Spec#initProvider
   */
  readonly initProvider?: RecordV1Beta2SpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema RecordV1Beta2Spec#managementPolicies
   */
  readonly managementPolicies?: RecordV1Beta2SpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema RecordV1Beta2Spec#providerConfigRef
   */
  readonly providerConfigRef?: RecordV1Beta2SpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema RecordV1Beta2Spec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: RecordV1Beta2SpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema RecordV1Beta2Spec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: RecordV1Beta2SpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'RecordV1Beta2Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2Spec(obj: RecordV1Beta2Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_RecordV1Beta2SpecForProvider(obj.forProvider),
    'initProvider': toJson_RecordV1Beta2SpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_RecordV1Beta2SpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_RecordV1Beta2SpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_RecordV1Beta2SpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema RecordV1Beta2SpecDeletionPolicy
 */
export enum RecordV1Beta2SpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema RecordV1Beta2SpecForProvider
 */
export interface RecordV1Beta2SpecForProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#alias
   */
  readonly alias?: RecordV1Beta2SpecForProviderAlias;

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordV1Beta2SpecForProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordV1Beta2SpecForProviderCidrRoutingPolicy;

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordV1Beta2SpecForProviderFailoverRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordV1Beta2SpecForProviderGeolocationRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy;

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordV1Beta2SpecForProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecForProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordV1Beta2SpecForProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: RecordV1Beta2SpecForProviderLatencyRoutingPolicy;

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordV1Beta2SpecForProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecForProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordV1Beta2SpecForProvider#records
   */
  readonly records?: string[];

  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   * Region is the region you'd like your resource to be created in.
   *
   * @schema RecordV1Beta2SpecForProvider#region
   */
  readonly region: string;

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordV1Beta2SpecForProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordV1Beta2SpecForProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecForProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecForProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordV1Beta2SpecForProviderWeightedRoutingPolicy;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordV1Beta2SpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordV1Beta2SpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProvider(obj: RecordV1Beta2SpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': toJson_RecordV1Beta2SpecForProviderAlias(obj.alias),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': toJson_RecordV1Beta2SpecForProviderCidrRoutingPolicy(obj.cidrRoutingPolicy),
    'failoverRoutingPolicy': toJson_RecordV1Beta2SpecForProviderFailoverRoutingPolicy(obj.failoverRoutingPolicy),
    'geolocationRoutingPolicy': toJson_RecordV1Beta2SpecForProviderGeolocationRoutingPolicy(obj.geolocationRoutingPolicy),
    'geoproximityRoutingPolicy': toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy(obj.geoproximityRoutingPolicy),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordV1Beta2SpecForProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': toJson_RecordV1Beta2SpecForProviderLatencyRoutingPolicy(obj.latencyRoutingPolicy),
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'region': obj.region,
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': toJson_RecordV1Beta2SpecForProviderWeightedRoutingPolicy(obj.weightedRoutingPolicy),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordV1Beta2SpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordV1Beta2SpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema RecordV1Beta2SpecInitProvider
 */
export interface RecordV1Beta2SpecInitProvider {
  /**
   * An alias block. Conflicts with ttl & records.
   * Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#alias
   */
  readonly alias?: RecordV1Beta2SpecInitProviderAlias;

  /**
   * false by default. This configuration is not recommended for most environments.
   *
   * @schema RecordV1Beta2SpecInitProvider#allowOverwrite
   */
  readonly allowOverwrite?: boolean;

  /**
   * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#cidrRoutingPolicy
   */
  readonly cidrRoutingPolicy?: RecordV1Beta2SpecInitProviderCidrRoutingPolicy;

  /**
   * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#failoverRoutingPolicy
   */
  readonly failoverRoutingPolicy?: RecordV1Beta2SpecInitProviderFailoverRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#geolocationRoutingPolicy
   */
  readonly geolocationRoutingPolicy?: RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy;

  /**
   * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#geoproximityRoutingPolicy
   */
  readonly geoproximityRoutingPolicy?: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy;

  /**
   * The health check the record should be associated with.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckId
   */
  readonly healthCheckId?: string;

  /**
   * Reference to a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckIdRef
   */
  readonly healthCheckIdRef?: RecordV1Beta2SpecInitProviderHealthCheckIdRef;

  /**
   * Selector for a HealthCheck in route53 to populate healthCheckId.
   *
   * @schema RecordV1Beta2SpecInitProvider#healthCheckIdSelector
   */
  readonly healthCheckIdSelector?: RecordV1Beta2SpecInitProviderHealthCheckIdSelector;

  /**
   * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#latencyRoutingPolicy
   */
  readonly latencyRoutingPolicy?: any;

  /**
   * Set to true to indicate a multivalue answer routing policy. Conflicts with any other routing policy.
   *
   * @schema RecordV1Beta2SpecInitProvider#multivalueAnswerRoutingPolicy
   */
  readonly multivalueAnswerRoutingPolicy?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecInitProvider#name
   */
  readonly name?: string;

  /**
   * A string list of records.g., "first255characters\"\"morecharacters").
   *
   * @schema RecordV1Beta2SpecInitProvider#records
   */
  readonly records?: string[];

  /**
   * Unique identifier to differentiate records with routing policies from one another. Required if using cidr_routing_policy, failover_routing_policy, geolocation_routing_policy,geoproximity_routing_policy, latency_routing_policy, multivalue_answer_routing_policy, or weighted_routing_policy.
   *
   * @schema RecordV1Beta2SpecInitProvider#setIdentifier
   */
  readonly setIdentifier?: string;

  /**
   * The TTL of the record.
   *
   * @schema RecordV1Beta2SpecInitProvider#ttl
   */
  readonly ttl?: number;

  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecInitProvider#type
   */
  readonly type?: string;

  /**
   * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
   *
   * @schema RecordV1Beta2SpecInitProvider#weightedRoutingPolicy
   */
  readonly weightedRoutingPolicy?: RecordV1Beta2SpecInitProviderWeightedRoutingPolicy;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: RecordV1Beta2SpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema RecordV1Beta2SpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: RecordV1Beta2SpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProvider(obj: RecordV1Beta2SpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': toJson_RecordV1Beta2SpecInitProviderAlias(obj.alias),
    'allowOverwrite': obj.allowOverwrite,
    'cidrRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderCidrRoutingPolicy(obj.cidrRoutingPolicy),
    'failoverRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderFailoverRoutingPolicy(obj.failoverRoutingPolicy),
    'geolocationRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy(obj.geolocationRoutingPolicy),
    'geoproximityRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy(obj.geoproximityRoutingPolicy),
    'healthCheckId': obj.healthCheckId,
    'healthCheckIdRef': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRef(obj.healthCheckIdRef),
    'healthCheckIdSelector': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelector(obj.healthCheckIdSelector),
    'latencyRoutingPolicy': obj.latencyRoutingPolicy,
    'multivalueAnswerRoutingPolicy': obj.multivalueAnswerRoutingPolicy,
    'name': obj.name,
    'records': obj.records?.map(y => y),
    'setIdentifier': obj.setIdentifier,
    'ttl': obj.ttl,
    'type': obj.type,
    'weightedRoutingPolicy': toJson_RecordV1Beta2SpecInitProviderWeightedRoutingPolicy(obj.weightedRoutingPolicy),
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_RecordV1Beta2SpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_RecordV1Beta2SpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema RecordV1Beta2SpecManagementPolicies
 */
export enum RecordV1Beta2SpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema RecordV1Beta2SpecProviderConfigRef
 */
export interface RecordV1Beta2SpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecProviderConfigRef#policy
   */
  readonly policy?: RecordV1Beta2SpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecProviderConfigRef(obj: RecordV1Beta2SpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsTo
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: RecordV1Beta2SpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsTo(obj: RecordV1Beta2SpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_RecordV1Beta2SpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema RecordV1Beta2SpecWriteConnectionSecretToRef
 */
export interface RecordV1Beta2SpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema RecordV1Beta2SpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema RecordV1Beta2SpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecWriteConnectionSecretToRef(obj: RecordV1Beta2SpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An alias block. Conflicts with ttl & records.
 * Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderAlias
 */
export interface RecordV1Beta2SpecForProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecForProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderAlias(obj: RecordV1Beta2SpecForProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordV1Beta2SpecForProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderCidrRoutingPolicy(obj: RecordV1Beta2SpecForProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderFailoverRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecForProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderFailoverRoutingPolicy(obj: RecordV1Beta2SpecForProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordV1Beta2SpecForProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeolocationRoutingPolicy(obj: RecordV1Beta2SpecForProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy(obj: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdRef(obj: RecordV1Beta2SpecForProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelector(obj: RecordV1Beta2SpecForProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the latency between the requestor and an AWS region. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderLatencyRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderLatencyRoutingPolicy {
  /**
   * An AWS region from which to measure latency. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-latency
   *
   * @schema RecordV1Beta2SpecForProviderLatencyRoutingPolicy#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderLatencyRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderLatencyRoutingPolicy(obj: RecordV1Beta2SpecForProviderLatencyRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecForProviderWeightedRoutingPolicy
 */
export interface RecordV1Beta2SpecForProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordV1Beta2SpecForProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderWeightedRoutingPolicy(obj: RecordV1Beta2SpecForProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRef
 */
export interface RecordV1Beta2SpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdRef(obj: RecordV1Beta2SpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelector
 */
export interface RecordV1Beta2SpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdSelector(obj: RecordV1Beta2SpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * An alias block. Conflicts with ttl & records.
 * Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderAlias
 */
export interface RecordV1Beta2SpecInitProviderAlias {
  /**
   * Set to true if you want Route 53 to determine whether to respond to DNS queries using this resource record set by checking the health of the resource record set. Some resources have special requirements, see related part of documentation.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#evaluateTargetHealth
   */
  readonly evaluateTargetHealth?: boolean;

  /**
   * The name of the record.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#name
   */
  readonly name?: string;

  /**
   * The ID of the hosted zone to contain this record.
   *
   * @schema RecordV1Beta2SpecInitProviderAlias#zoneId
   */
  readonly zoneId?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderAlias' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderAlias(obj: RecordV1Beta2SpecInitProviderAlias | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'evaluateTargetHealth': obj.evaluateTargetHealth,
    'name': obj.name,
    'zoneId': obj.zoneId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the IP network ranges of requestors. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderCidrRoutingPolicy {
  /**
   * The CIDR collection ID. See the aws_route53_cidr_collection resource for more details.
   *
   * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy#collectionId
   */
  readonly collectionId?: string;

  /**
   * The CIDR collection location name. See the aws_route53_cidr_location resource for more details. A location_name with an asterisk "*" can be used to create a default CIDR record. collection_id is still required for default record.
   *
   * @schema RecordV1Beta2SpecInitProviderCidrRoutingPolicy#locationName
   */
  readonly locationName?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderCidrRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderCidrRoutingPolicy(obj: RecordV1Beta2SpecInitProviderCidrRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'collectionId': obj.collectionId,
    'locationName': obj.locationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating the routing behavior when associated health check fails. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderFailoverRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderFailoverRoutingPolicy {
  /**
   * The record type. Valid values are A, AAAA, CAA, CNAME, DS, MX, NAPTR, NS, PTR, SOA, SPF, SRV and TXT.
   *
   * @schema RecordV1Beta2SpecInitProviderFailoverRoutingPolicy#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderFailoverRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderFailoverRoutingPolicy(obj: RecordV1Beta2SpecInitProviderFailoverRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geolocation of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy {
  /**
   * A two-letter continent code. See http://docs.aws.amazon.com/Route53/latest/APIReference/API_GetGeoLocation.html for code details. Either continent or country must be specified.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#continent
   */
  readonly continent?: string;

  /**
   * A two-character country code or * to indicate a default resource record set.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#country
   */
  readonly country?: string;

  /**
   * A subdivision code for a country.
   *
   * @schema RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy#subdivision
   */
  readonly subdivision?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy(obj: RecordV1Beta2SpecInitProviderGeolocationRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'continent': obj.continent,
    'country': obj.country,
    'subdivision': obj.subdivision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a routing policy based on the geoproximity of the requestor. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy {
  /**
   * A AWS region where the resource is present.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#awsRegion
   */
  readonly awsRegion?: string;

  /**
   * Route more traffic or less traffic to the resource by specifying a value ranges between -90 to 90. See https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-geoproximity.html for bias details.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#bias
   */
  readonly bias?: number;

  /**
   * Specify latitude and longitude for routing traffic to non-AWS resources.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#coordinates
   */
  readonly coordinates?: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates[];

  /**
   * A AWS local zone group where the resource is present. See https://docs.aws.amazon.com/local-zones/latest/ug/available-local-zones.html for local zone group list.
   *
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy#localZoneGroup
   */
  readonly localZoneGroup?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy(obj: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'awsRegion': obj.awsRegion,
    'bias': obj.bias,
    'coordinates': obj.coordinates?.map(y => toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates(y)),
    'localZoneGroup': obj.localZoneGroup,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRef(obj: RecordV1Beta2SpecInitProviderHealthCheckIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a HealthCheck in route53 to populate healthCheckId.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelector(obj: RecordV1Beta2SpecInitProviderHealthCheckIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A block indicating a weighted routing policy. Conflicts with any other routing policy. Documented below.
 *
 * @schema RecordV1Beta2SpecInitProviderWeightedRoutingPolicy
 */
export interface RecordV1Beta2SpecInitProviderWeightedRoutingPolicy {
  /**
   * A numeric value indicating the relative weight of the record. See http://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted.
   *
   * @schema RecordV1Beta2SpecInitProviderWeightedRoutingPolicy#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderWeightedRoutingPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderWeightedRoutingPolicy(obj: RecordV1Beta2SpecInitProviderWeightedRoutingPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRef
 */
export interface RecordV1Beta2SpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRef#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdRef(obj: RecordV1Beta2SpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelector
 */
export interface RecordV1Beta2SpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdSelector(obj: RecordV1Beta2SpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicy
 */
export interface RecordV1Beta2SpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecProviderConfigRefPolicy(obj: RecordV1Beta2SpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRef(obj: RecordV1Beta2SpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToMetadata(obj: RecordV1Beta2SpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates(obj: RecordV1Beta2SpecForProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy(obj: RecordV1Beta2SpecForProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy
 */
export interface RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy(obj: RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy
 */
export interface RecordV1Beta2SpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdRefPolicy(obj: RecordV1Beta2SpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy
 */
export interface RecordV1Beta2SpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecForProviderZoneIdSelectorPolicy(obj: RecordV1Beta2SpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates
 */
export interface RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates {
  /**
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates#latitude
   */
  readonly latitude?: string;

  /**
   * @schema RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates#longitude
   */
  readonly longitude?: string;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates(obj: RecordV1Beta2SpecInitProviderGeoproximityRoutingPolicyCoordinates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'latitude': obj.latitude,
    'longitude': obj.longitude,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy(obj: RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy
 */
export interface RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy(obj: RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy
 */
export interface RecordV1Beta2SpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdRefPolicy(obj: RecordV1Beta2SpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy
 */
export interface RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy(obj: RecordV1Beta2SpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicyResolution
 */
export enum RecordV1Beta2SpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecProviderConfigRefPolicyResolve
 */
export enum RecordV1Beta2SpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy(obj: RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderHealthCheckIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum RecordV1Beta2SpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum RecordV1Beta2SpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ResolverConfig is the Schema for the ResolverConfigs API. Provides a Route 53 Resolver config resource.
 *
 * @schema ResolverConfig
 */
export class Route53ResolverConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ResolverConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'ResolverConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ResolverConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53ResolverConfigProps): any {
    return {
      ...Route53ResolverConfig.GVK,
      ...toJson_Route53ResolverConfigProps(props),
    };
  }

  /**
   * Defines a "ResolverConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53ResolverConfigProps) {
    super(scope, id, {
      ...Route53ResolverConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53ResolverConfig.GVK,
      ...toJson_Route53ResolverConfigProps(resolved),
    };
  }
}

/**
 * ResolverConfig is the Schema for the ResolverConfigs API. Provides a Route 53 Resolver config resource.
 *
 * @schema ResolverConfig
 */
export interface Route53ResolverConfigProps {
  /**
   * @schema ResolverConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ResolverConfigSpec defines the desired state of ResolverConfig
   *
   * @schema ResolverConfig#spec
   */
  readonly spec: ResolverConfigSpec;

}

/**
 * Converts an object of type 'Route53ResolverConfigProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53ResolverConfigProps(obj: Route53ResolverConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ResolverConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResolverConfigSpec defines the desired state of ResolverConfig
 *
 * @schema ResolverConfigSpec
 */
export interface ResolverConfigSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ResolverConfigSpec#deletionPolicy
   */
  readonly deletionPolicy?: ResolverConfigSpecDeletionPolicy;

  /**
   * @schema ResolverConfigSpec#forProvider
   */
  readonly forProvider: ResolverConfigSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ResolverConfigSpec#initProvider
   */
  readonly initProvider?: ResolverConfigSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ResolverConfigSpec#managementPolicies
   */
  readonly managementPolicies?: ResolverConfigSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ResolverConfigSpec#providerConfigRef
   */
  readonly providerConfigRef?: ResolverConfigSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ResolverConfigSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ResolverConfigSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ResolverConfigSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ResolverConfigSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ResolverConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpec(obj: ResolverConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ResolverConfigSpecForProvider(obj.forProvider),
    'initProvider': toJson_ResolverConfigSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ResolverConfigSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ResolverConfigSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ResolverConfigSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ResolverConfigSpecDeletionPolicy
 */
export enum ResolverConfigSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ResolverConfigSpecForProvider
 */
export interface ResolverConfigSpecForProvider {
  /**
   * Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. Valid values: ENABLE, DISABLE.
   *
   * @schema ResolverConfigSpecForProvider#autodefinedReverseFlag
   */
  readonly autodefinedReverseFlag?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ResolverConfigSpecForProvider#region
   */
  readonly region: string;

  /**
   * The ID of the VPC that the configuration is for.
   *
   * @schema ResolverConfigSpecForProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecForProvider#resourceIdRef
   */
  readonly resourceIdRef?: ResolverConfigSpecForProviderResourceIdRef;

  /**
   * Selector for a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecForProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: ResolverConfigSpecForProviderResourceIdSelector;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProvider(obj: ResolverConfigSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autodefinedReverseFlag': obj.autodefinedReverseFlag,
    'region': obj.region,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_ResolverConfigSpecForProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_ResolverConfigSpecForProviderResourceIdSelector(obj.resourceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ResolverConfigSpecInitProvider
 */
export interface ResolverConfigSpecInitProvider {
  /**
   * Indicates whether or not the Resolver will create autodefined rules for reverse DNS lookups. Valid values: ENABLE, DISABLE.
   *
   * @schema ResolverConfigSpecInitProvider#autodefinedReverseFlag
   */
  readonly autodefinedReverseFlag?: string;

  /**
   * The ID of the VPC that the configuration is for.
   *
   * @schema ResolverConfigSpecInitProvider#resourceId
   */
  readonly resourceId?: string;

  /**
   * Reference to a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecInitProvider#resourceIdRef
   */
  readonly resourceIdRef?: ResolverConfigSpecInitProviderResourceIdRef;

  /**
   * Selector for a VPC in ec2 to populate resourceId.
   *
   * @schema ResolverConfigSpecInitProvider#resourceIdSelector
   */
  readonly resourceIdSelector?: ResolverConfigSpecInitProviderResourceIdSelector;

}

/**
 * Converts an object of type 'ResolverConfigSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecInitProvider(obj: ResolverConfigSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autodefinedReverseFlag': obj.autodefinedReverseFlag,
    'resourceId': obj.resourceId,
    'resourceIdRef': toJson_ResolverConfigSpecInitProviderResourceIdRef(obj.resourceIdRef),
    'resourceIdSelector': toJson_ResolverConfigSpecInitProviderResourceIdSelector(obj.resourceIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ResolverConfigSpecManagementPolicies
 */
export enum ResolverConfigSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ResolverConfigSpecProviderConfigRef
 */
export interface ResolverConfigSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecProviderConfigRef#policy
   */
  readonly policy?: ResolverConfigSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderConfigRef(obj: ResolverConfigSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsTo
 */
export interface ResolverConfigSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ResolverConfigSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ResolverConfigSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsTo(obj: ResolverConfigSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ResolverConfigSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ResolverConfigSpecWriteConnectionSecretToRef
 */
export interface ResolverConfigSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ResolverConfigSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ResolverConfigSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecWriteConnectionSecretToRef(obj: ResolverConfigSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRef
 */
export interface ResolverConfigSpecForProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRef#policy
   */
  readonly policy?: ResolverConfigSpecForProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdRef(obj: ResolverConfigSpecForProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecForProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelector
 */
export interface ResolverConfigSpecForProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelector#policy
   */
  readonly policy?: ResolverConfigSpecForProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdSelector(obj: ResolverConfigSpecForProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverConfigSpecForProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdRef
 */
export interface ResolverConfigSpecInitProviderResourceIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdRef#policy
   */
  readonly policy?: ResolverConfigSpecInitProviderResourceIdRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecInitProviderResourceIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecInitProviderResourceIdRef(obj: ResolverConfigSpecInitProviderResourceIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecInitProviderResourceIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate resourceId.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdSelector
 */
export interface ResolverConfigSpecInitProviderResourceIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdSelector#policy
   */
  readonly policy?: ResolverConfigSpecInitProviderResourceIdSelectorPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecInitProviderResourceIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecInitProviderResourceIdSelector(obj: ResolverConfigSpecInitProviderResourceIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ResolverConfigSpecInitProviderResourceIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicy
 */
export interface ResolverConfigSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecProviderConfigRefPolicy(obj: ResolverConfigSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef
 */
export interface ResolverConfigSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRef(obj: ResolverConfigSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata
 */
export interface ResolverConfigSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToMetadata(obj: ResolverConfigSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicy
 */
export interface ResolverConfigSpecForProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecForProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecForProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecForProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdRefPolicy(obj: ResolverConfigSpecForProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy
 */
export interface ResolverConfigSpecForProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecForProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecForProviderResourceIdSelectorPolicy(obj: ResolverConfigSpecForProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdRefPolicy
 */
export interface ResolverConfigSpecInitProviderResourceIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecInitProviderResourceIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecInitProviderResourceIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecInitProviderResourceIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecInitProviderResourceIdRefPolicy(obj: ResolverConfigSpecInitProviderResourceIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdSelectorPolicy
 */
export interface ResolverConfigSpecInitProviderResourceIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdSelectorPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecInitProviderResourceIdSelectorPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecInitProviderResourceIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecInitProviderResourceIdSelectorPolicy(obj: ResolverConfigSpecInitProviderResourceIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicyResolution
 */
export enum ResolverConfigSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecProviderConfigRefPolicyResolve
 */
export enum ResolverConfigSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy(obj: ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicyResolution
 */
export enum ResolverConfigSpecForProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecForProviderResourceIdRefPolicyResolve
 */
export enum ResolverConfigSpecForProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution
 */
export enum ResolverConfigSpecForProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve
 */
export enum ResolverConfigSpecForProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdRefPolicyResolution
 */
export enum ResolverConfigSpecInitProviderResourceIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdRefPolicyResolve
 */
export enum ResolverConfigSpecInitProviderResourceIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolution
 */
export enum ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolve
 */
export enum ResolverConfigSpecInitProviderResourceIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ResolverConfigSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrafficPolicy is the Schema for the TrafficPolicys API. Manages a Route53 Traffic Policy
 *
 * @schema TrafficPolicy
 */
export class Route53TrafficPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrafficPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'TrafficPolicy',
  }

  /**
   * Renders a Kubernetes manifest for "TrafficPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53TrafficPolicyProps): any {
    return {
      ...Route53TrafficPolicy.GVK,
      ...toJson_Route53TrafficPolicyProps(props),
    };
  }

  /**
   * Defines a "TrafficPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53TrafficPolicyProps) {
    super(scope, id, {
      ...Route53TrafficPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53TrafficPolicy.GVK,
      ...toJson_Route53TrafficPolicyProps(resolved),
    };
  }
}

/**
 * TrafficPolicy is the Schema for the TrafficPolicys API. Manages a Route53 Traffic Policy
 *
 * @schema TrafficPolicy
 */
export interface Route53TrafficPolicyProps {
  /**
   * @schema TrafficPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrafficPolicySpec defines the desired state of TrafficPolicy
   *
   * @schema TrafficPolicy#spec
   */
  readonly spec: TrafficPolicySpec;

}

/**
 * Converts an object of type 'Route53TrafficPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53TrafficPolicyProps(obj: Route53TrafficPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrafficPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrafficPolicySpec defines the desired state of TrafficPolicy
 *
 * @schema TrafficPolicySpec
 */
export interface TrafficPolicySpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicySpec#deletionPolicy
   */
  readonly deletionPolicy?: TrafficPolicySpecDeletionPolicy;

  /**
   * @schema TrafficPolicySpec#forProvider
   */
  readonly forProvider: TrafficPolicySpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema TrafficPolicySpec#initProvider
   */
  readonly initProvider?: TrafficPolicySpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TrafficPolicySpec#managementPolicies
   */
  readonly managementPolicies?: TrafficPolicySpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema TrafficPolicySpec#providerConfigRef
   */
  readonly providerConfigRef?: TrafficPolicySpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema TrafficPolicySpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrafficPolicySpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema TrafficPolicySpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrafficPolicySpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrafficPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpec(obj: TrafficPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrafficPolicySpecForProvider(obj.forProvider),
    'initProvider': toJson_TrafficPolicySpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TrafficPolicySpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TrafficPolicySpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrafficPolicySpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicySpecDeletionPolicy
 */
export enum TrafficPolicySpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrafficPolicySpecForProvider
 */
export interface TrafficPolicySpecForProvider {
  /**
   * Comment for the traffic policy.
   *
   * @schema TrafficPolicySpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * Policy document. This is a JSON formatted string. For more information about building Route53 traffic policy documents, see the AWS Route53 Traffic Policy document format
   *
   * @schema TrafficPolicySpecForProvider#document
   */
  readonly document?: string;

  /**
   * Name of the traffic policy.
   *
   * @schema TrafficPolicySpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrafficPolicySpecForProvider#region
   */
  readonly region: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecForProvider(obj: TrafficPolicySpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'document': obj.document,
    'name': obj.name,
    'region': obj.region,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema TrafficPolicySpecInitProvider
 */
export interface TrafficPolicySpecInitProvider {
  /**
   * Comment for the traffic policy.
   *
   * @schema TrafficPolicySpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * Policy document. This is a JSON formatted string. For more information about building Route53 traffic policy documents, see the AWS Route53 Traffic Policy document format
   *
   * @schema TrafficPolicySpecInitProvider#document
   */
  readonly document?: string;

  /**
   * Name of the traffic policy.
   *
   * @schema TrafficPolicySpecInitProvider#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecInitProvider(obj: TrafficPolicySpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'document': obj.document,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema TrafficPolicySpecManagementPolicies
 */
export enum TrafficPolicySpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema TrafficPolicySpecProviderConfigRef
 */
export interface TrafficPolicySpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicySpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicySpecProviderConfigRef#policy
   */
  readonly policy?: TrafficPolicySpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderConfigRef(obj: TrafficPolicySpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicySpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsTo
 */
export interface TrafficPolicySpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrafficPolicySpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrafficPolicySpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsTo(obj: TrafficPolicySpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrafficPolicySpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema TrafficPolicySpecWriteConnectionSecretToRef
 */
export interface TrafficPolicySpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrafficPolicySpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrafficPolicySpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecWriteConnectionSecretToRef(obj: TrafficPolicySpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicy
 */
export interface TrafficPolicySpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicySpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicySpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicySpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicySpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicySpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecProviderConfigRefPolicy(obj: TrafficPolicySpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef
 */
export interface TrafficPolicySpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRef(obj: TrafficPolicySpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata
 */
export interface TrafficPolicySpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToMetadata(obj: TrafficPolicySpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicyResolution
 */
export enum TrafficPolicySpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicySpecProviderConfigRefPolicyResolve
 */
export enum TrafficPolicySpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy(obj: TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrafficPolicySpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * TrafficPolicyInstance is the Schema for the TrafficPolicyInstances API. Provides a Route53 traffic policy instance resource.
 *
 * @schema TrafficPolicyInstance
 */
export class Route53TrafficPolicyInstance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TrafficPolicyInstance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'TrafficPolicyInstance',
  }

  /**
   * Renders a Kubernetes manifest for "TrafficPolicyInstance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53TrafficPolicyInstanceProps): any {
    return {
      ...Route53TrafficPolicyInstance.GVK,
      ...toJson_Route53TrafficPolicyInstanceProps(props),
    };
  }

  /**
   * Defines a "TrafficPolicyInstance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53TrafficPolicyInstanceProps) {
    super(scope, id, {
      ...Route53TrafficPolicyInstance.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53TrafficPolicyInstance.GVK,
      ...toJson_Route53TrafficPolicyInstanceProps(resolved),
    };
  }
}

/**
 * TrafficPolicyInstance is the Schema for the TrafficPolicyInstances API. Provides a Route53 traffic policy instance resource.
 *
 * @schema TrafficPolicyInstance
 */
export interface Route53TrafficPolicyInstanceProps {
  /**
   * @schema TrafficPolicyInstance#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TrafficPolicyInstanceSpec defines the desired state of TrafficPolicyInstance
   *
   * @schema TrafficPolicyInstance#spec
   */
  readonly spec: TrafficPolicyInstanceSpec;

}

/**
 * Converts an object of type 'Route53TrafficPolicyInstanceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53TrafficPolicyInstanceProps(obj: Route53TrafficPolicyInstanceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TrafficPolicyInstanceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TrafficPolicyInstanceSpec defines the desired state of TrafficPolicyInstance
 *
 * @schema TrafficPolicyInstanceSpec
 */
export interface TrafficPolicyInstanceSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema TrafficPolicyInstanceSpec#deletionPolicy
   */
  readonly deletionPolicy?: TrafficPolicyInstanceSpecDeletionPolicy;

  /**
   * @schema TrafficPolicyInstanceSpec#forProvider
   */
  readonly forProvider: TrafficPolicyInstanceSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema TrafficPolicyInstanceSpec#initProvider
   */
  readonly initProvider?: TrafficPolicyInstanceSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema TrafficPolicyInstanceSpec#managementPolicies
   */
  readonly managementPolicies?: TrafficPolicyInstanceSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema TrafficPolicyInstanceSpec#providerConfigRef
   */
  readonly providerConfigRef?: TrafficPolicyInstanceSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema TrafficPolicyInstanceSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: TrafficPolicyInstanceSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema TrafficPolicyInstanceSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: TrafficPolicyInstanceSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpec(obj: TrafficPolicyInstanceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_TrafficPolicyInstanceSpecForProvider(obj.forProvider),
    'initProvider': toJson_TrafficPolicyInstanceSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_TrafficPolicyInstanceSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_TrafficPolicyInstanceSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema TrafficPolicyInstanceSpecDeletionPolicy
 */
export enum TrafficPolicyInstanceSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema TrafficPolicyInstanceSpecForProvider
 */
export interface TrafficPolicyInstanceSpecForProvider {
  /**
   * ID of the hosted zone that you want Amazon Route 53 to create resource record sets in by using the configuration in a traffic policy.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone in route53 to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector;

  /**
   * Domain name for which Amazon Route 53 responds to DNS queries by using the resource record sets that Route 53 creates for this traffic policy instance.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#region
   */
  readonly region: string;

  /**
   * ID of the traffic policy that you want to use to create resource record sets in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyId
   */
  readonly trafficPolicyId?: string;

  /**
   * Reference to a TrafficPolicy in route53 to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyIdRef
   */
  readonly trafficPolicyIdRef?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef;

  /**
   * Selector for a TrafficPolicy in route53 to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyIdSelector
   */
  readonly trafficPolicyIdSelector?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector;

  /**
   * Version of the traffic policy
   *
   * @schema TrafficPolicyInstanceSpecForProvider#trafficPolicyVersion
   */
  readonly trafficPolicyVersion?: number;

  /**
   * TTL that you want Amazon Route 53 to assign to all the resource record sets that it creates in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecForProvider#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProvider(obj: TrafficPolicyInstanceSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'name': obj.name,
    'region': obj.region,
    'trafficPolicyId': obj.trafficPolicyId,
    'trafficPolicyIdRef': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef(obj.trafficPolicyIdRef),
    'trafficPolicyIdSelector': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector(obj.trafficPolicyIdSelector),
    'trafficPolicyVersion': obj.trafficPolicyVersion,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema TrafficPolicyInstanceSpecInitProvider
 */
export interface TrafficPolicyInstanceSpecInitProvider {
  /**
   * ID of the hosted zone that you want Amazon Route 53 to create resource record sets in by using the configuration in a traffic policy.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#hostedZoneId
   */
  readonly hostedZoneId?: string;

  /**
   * Reference to a Zone in route53 to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#hostedZoneIdRef
   */
  readonly hostedZoneIdRef?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate hostedZoneId.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#hostedZoneIdSelector
   */
  readonly hostedZoneIdSelector?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector;

  /**
   * Domain name for which Amazon Route 53 responds to DNS queries by using the resource record sets that Route 53 creates for this traffic policy instance.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * ID of the traffic policy that you want to use to create resource record sets in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#trafficPolicyId
   */
  readonly trafficPolicyId?: string;

  /**
   * Reference to a TrafficPolicy in route53 to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#trafficPolicyIdRef
   */
  readonly trafficPolicyIdRef?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef;

  /**
   * Selector for a TrafficPolicy in route53 to populate trafficPolicyId.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#trafficPolicyIdSelector
   */
  readonly trafficPolicyIdSelector?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector;

  /**
   * Version of the traffic policy
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#trafficPolicyVersion
   */
  readonly trafficPolicyVersion?: number;

  /**
   * TTL that you want Amazon Route 53 to assign to all the resource record sets that it creates in the specified hosted zone.
   *
   * @schema TrafficPolicyInstanceSpecInitProvider#ttl
   */
  readonly ttl?: number;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProvider(obj: TrafficPolicyInstanceSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostedZoneId': obj.hostedZoneId,
    'hostedZoneIdRef': toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef(obj.hostedZoneIdRef),
    'hostedZoneIdSelector': toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector(obj.hostedZoneIdSelector),
    'name': obj.name,
    'trafficPolicyId': obj.trafficPolicyId,
    'trafficPolicyIdRef': toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef(obj.trafficPolicyIdRef),
    'trafficPolicyIdSelector': toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector(obj.trafficPolicyIdSelector),
    'trafficPolicyVersion': obj.trafficPolicyVersion,
    'ttl': obj.ttl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema TrafficPolicyInstanceSpecManagementPolicies
 */
export enum TrafficPolicyInstanceSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRef
 */
export interface TrafficPolicyInstanceSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderConfigRef(obj: TrafficPolicyInstanceSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsTo(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef
 */
export interface TrafficPolicyInstanceSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema TrafficPolicyInstanceSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecWriteConnectionSecretToRef(obj: TrafficPolicyInstanceSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRef(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TrafficPolicy in route53 to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TrafficPolicy in route53 to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef
 */
export interface TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef(obj: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate hostedZoneId.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector
 */
export interface TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector(obj: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a TrafficPolicy in route53 to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef
 */
export interface TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef(obj: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a TrafficPolicy in route53 to populate trafficPolicyId.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector
 */
export interface TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector(obj: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy
 */
export interface TrafficPolicyInstanceSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecProviderConfigRefPolicy(obj: TrafficPolicyInstanceSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy(obj: TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy(obj: TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy(obj: TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy(obj: TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy
 */
export interface TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy(obj: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy
 */
export interface TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy(obj: TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy(obj: TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecForProviderTrafficPolicyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecInitProviderHostedZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecInitProviderHostedZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolution
 */
export enum TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolve
 */
export enum TrafficPolicyInstanceSpecInitProviderTrafficPolicyIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum TrafficPolicyInstanceSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * VPCAssociationAuthorization is the Schema for the VPCAssociationAuthorizations API. Authorizes a VPC in a different account to be associated with a local Route53 Hosted Zone
 *
 * @schema VPCAssociationAuthorization
 */
export class Route53VpcAssociationAuthorization extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VPCAssociationAuthorization"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'VPCAssociationAuthorization',
  }

  /**
   * Renders a Kubernetes manifest for "VPCAssociationAuthorization".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53VpcAssociationAuthorizationProps): any {
    return {
      ...Route53VpcAssociationAuthorization.GVK,
      ...toJson_Route53VpcAssociationAuthorizationProps(props),
    };
  }

  /**
   * Defines a "VPCAssociationAuthorization" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53VpcAssociationAuthorizationProps) {
    super(scope, id, {
      ...Route53VpcAssociationAuthorization.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53VpcAssociationAuthorization.GVK,
      ...toJson_Route53VpcAssociationAuthorizationProps(resolved),
    };
  }
}

/**
 * VPCAssociationAuthorization is the Schema for the VPCAssociationAuthorizations API. Authorizes a VPC in a different account to be associated with a local Route53 Hosted Zone
 *
 * @schema VPCAssociationAuthorization
 */
export interface Route53VpcAssociationAuthorizationProps {
  /**
   * @schema VPCAssociationAuthorization#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VPCAssociationAuthorizationSpec defines the desired state of VPCAssociationAuthorization
   *
   * @schema VPCAssociationAuthorization#spec
   */
  readonly spec: VpcAssociationAuthorizationSpec;

}

/**
 * Converts an object of type 'Route53VpcAssociationAuthorizationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53VpcAssociationAuthorizationProps(obj: Route53VpcAssociationAuthorizationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VpcAssociationAuthorizationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VPCAssociationAuthorizationSpec defines the desired state of VPCAssociationAuthorization
 *
 * @schema VpcAssociationAuthorizationSpec
 */
export interface VpcAssociationAuthorizationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema VpcAssociationAuthorizationSpec#deletionPolicy
   */
  readonly deletionPolicy?: VpcAssociationAuthorizationSpecDeletionPolicy;

  /**
   * @schema VpcAssociationAuthorizationSpec#forProvider
   */
  readonly forProvider: VpcAssociationAuthorizationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema VpcAssociationAuthorizationSpec#initProvider
   */
  readonly initProvider?: VpcAssociationAuthorizationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema VpcAssociationAuthorizationSpec#managementPolicies
   */
  readonly managementPolicies?: VpcAssociationAuthorizationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema VpcAssociationAuthorizationSpec#providerConfigRef
   */
  readonly providerConfigRef?: VpcAssociationAuthorizationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema VpcAssociationAuthorizationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: VpcAssociationAuthorizationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema VpcAssociationAuthorizationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: VpcAssociationAuthorizationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpec(obj: VpcAssociationAuthorizationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_VpcAssociationAuthorizationSpecForProvider(obj.forProvider),
    'initProvider': toJson_VpcAssociationAuthorizationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_VpcAssociationAuthorizationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_VpcAssociationAuthorizationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema VpcAssociationAuthorizationSpecDeletionPolicy
 */
export enum VpcAssociationAuthorizationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema VpcAssociationAuthorizationSpecForProvider
 */
export interface VpcAssociationAuthorizationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The VPC to authorize for association with the private hosted zone.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpcAssociationAuthorizationSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpcAssociationAuthorizationSpecForProviderVpcIdSelector;

  /**
   * The VPC's region. Defaults to the region of the AWS provider.
   *
   * @default the region of the AWS provider.
   * @schema VpcAssociationAuthorizationSpecForProvider#vpcRegion
   */
  readonly vpcRegion?: string;

  /**
   * The ID of the private hosted zone that you want to authorize associating a VPC with.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: VpcAssociationAuthorizationSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: VpcAssociationAuthorizationSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProvider(obj: VpcAssociationAuthorizationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema VpcAssociationAuthorizationSpecInitProvider
 */
export interface VpcAssociationAuthorizationSpecInitProvider {
  /**
   * The VPC to authorize for association with the private hosted zone.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#vpcIdRef
   */
  readonly vpcIdRef?: VpcAssociationAuthorizationSpecInitProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: VpcAssociationAuthorizationSpecInitProviderVpcIdSelector;

  /**
   * The VPC's region. Defaults to the region of the AWS provider.
   *
   * @default the region of the AWS provider.
   * @schema VpcAssociationAuthorizationSpecInitProvider#vpcRegion
   */
  readonly vpcRegion?: string;

  /**
   * The ID of the private hosted zone that you want to authorize associating a VPC with.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: VpcAssociationAuthorizationSpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema VpcAssociationAuthorizationSpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: VpcAssociationAuthorizationSpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProvider(obj: VpcAssociationAuthorizationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema VpcAssociationAuthorizationSpecManagementPolicies
 */
export enum VpcAssociationAuthorizationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRef
 */
export interface VpcAssociationAuthorizationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderConfigRef(obj: VpcAssociationAuthorizationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsTo(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef
 */
export interface VpcAssociationAuthorizationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema VpcAssociationAuthorizationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecWriteConnectionSecretToRef(obj: VpcAssociationAuthorizationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRef(obj: VpcAssociationAuthorizationSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelector(obj: VpcAssociationAuthorizationSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRef(obj: VpcAssociationAuthorizationSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelector(obj: VpcAssociationAuthorizationSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRef
 */
export interface VpcAssociationAuthorizationSpecInitProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdRef(obj: VpcAssociationAuthorizationSpecInitProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelector
 */
export interface VpcAssociationAuthorizationSpecInitProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdSelector(obj: VpcAssociationAuthorizationSpecInitProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRef
 */
export interface VpcAssociationAuthorizationSpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdRef(obj: VpcAssociationAuthorizationSpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelector
 */
export interface VpcAssociationAuthorizationSpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdSelector(obj: VpcAssociationAuthorizationSpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy
 */
export interface VpcAssociationAuthorizationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecProviderConfigRefPolicy(obj: VpcAssociationAuthorizationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy(obj: VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy(obj: VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy(obj: VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy
 */
export interface VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy(obj: VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy
 */
export interface VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy(obj: VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy(obj: VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecInitProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecInitProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum VpcAssociationAuthorizationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * Zone is the Schema for the Zones API. Manages a Route53 Hosted Zone
 *
 * @schema Zone
 */
export class Route53Zone extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Zone"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'Zone',
  }

  /**
   * Renders a Kubernetes manifest for "Zone".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53ZoneProps): any {
    return {
      ...Route53Zone.GVK,
      ...toJson_Route53ZoneProps(props),
    };
  }

  /**
   * Defines a "Zone" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53ZoneProps) {
    super(scope, id, {
      ...Route53Zone.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53Zone.GVK,
      ...toJson_Route53ZoneProps(resolved),
    };
  }
}

/**
 * Zone is the Schema for the Zones API. Manages a Route53 Hosted Zone
 *
 * @schema Zone
 */
export interface Route53ZoneProps {
  /**
   * @schema Zone#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZoneSpec defines the desired state of Zone
   *
   * @schema Zone#spec
   */
  readonly spec: ZoneSpec;

}

/**
 * Converts an object of type 'Route53ZoneProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53ZoneProps(obj: Route53ZoneProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ZoneSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ZoneSpec defines the desired state of Zone
 *
 * @schema ZoneSpec
 */
export interface ZoneSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneSpec#deletionPolicy
   */
  readonly deletionPolicy?: ZoneSpecDeletionPolicy;

  /**
   * @schema ZoneSpec#forProvider
   */
  readonly forProvider: ZoneSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ZoneSpec#initProvider
   */
  readonly initProvider?: ZoneSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ZoneSpec#managementPolicies
   */
  readonly managementPolicies?: ZoneSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ZoneSpec#providerConfigRef
   */
  readonly providerConfigRef?: ZoneSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ZoneSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ZoneSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ZoneSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ZoneSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ZoneSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpec(obj: ZoneSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ZoneSpecForProvider(obj.forProvider),
    'initProvider': toJson_ZoneSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ZoneSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ZoneSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ZoneSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneSpecDeletionPolicy
 */
export enum ZoneSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ZoneSpecForProvider
 */
export interface ZoneSpecForProvider {
  /**
   * A comment for the hosted zone.
   *
   * @schema ZoneSpecForProvider#comment
   */
  readonly comment?: string;

  /**
   * The ID of the reusable delegation set whose NS records you want to assign to the hosted zone. Conflicts with vpc as delegation sets can only be used for public zones.
   *
   * @schema ZoneSpecForProvider#delegationSetId
   */
  readonly delegationSetId?: string;

  /**
   * Reference to a DelegationSet in route53 to populate delegationSetId.
   *
   * @schema ZoneSpecForProvider#delegationSetIdRef
   */
  readonly delegationSetIdRef?: ZoneSpecForProviderDelegationSetIdRef;

  /**
   * Selector for a DelegationSet in route53 to populate delegationSetId.
   *
   * @schema ZoneSpecForProvider#delegationSetIdSelector
   */
  readonly delegationSetIdSelector?: ZoneSpecForProviderDelegationSetIdSelector;

  /**
   * @schema ZoneSpecForProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * This is the name of the hosted zone.
   *
   * @schema ZoneSpecForProvider#name
   */
  readonly name?: string;

  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ZoneSpecForProvider#region
   */
  readonly region: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ZoneSpecForProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block(s) specifying VPC(s) to associate with a private hosted zone. Conflicts with the delegation_set_id argument in this resource and any aws_route53_zone_association resource specifying the same zone ID. Detailed below.
   *
   * @schema ZoneSpecForProvider#vpc
   */
  readonly vpc?: ZoneSpecForProviderVpc[];

}

/**
 * Converts an object of type 'ZoneSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProvider(obj: ZoneSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'delegationSetId': obj.delegationSetId,
    'delegationSetIdRef': toJson_ZoneSpecForProviderDelegationSetIdRef(obj.delegationSetIdRef),
    'delegationSetIdSelector': toJson_ZoneSpecForProviderDelegationSetIdSelector(obj.delegationSetIdSelector),
    'forceDestroy': obj.forceDestroy,
    'name': obj.name,
    'region': obj.region,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpc': obj.vpc?.map(y => toJson_ZoneSpecForProviderVpc(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ZoneSpecInitProvider
 */
export interface ZoneSpecInitProvider {
  /**
   * A comment for the hosted zone.
   *
   * @schema ZoneSpecInitProvider#comment
   */
  readonly comment?: string;

  /**
   * The ID of the reusable delegation set whose NS records you want to assign to the hosted zone. Conflicts with vpc as delegation sets can only be used for public zones.
   *
   * @schema ZoneSpecInitProvider#delegationSetId
   */
  readonly delegationSetId?: string;

  /**
   * Reference to a DelegationSet in route53 to populate delegationSetId.
   *
   * @schema ZoneSpecInitProvider#delegationSetIdRef
   */
  readonly delegationSetIdRef?: ZoneSpecInitProviderDelegationSetIdRef;

  /**
   * Selector for a DelegationSet in route53 to populate delegationSetId.
   *
   * @schema ZoneSpecInitProvider#delegationSetIdSelector
   */
  readonly delegationSetIdSelector?: ZoneSpecInitProviderDelegationSetIdSelector;

  /**
   * @schema ZoneSpecInitProvider#forceDestroy
   */
  readonly forceDestroy?: boolean;

  /**
   * This is the name of the hosted zone.
   *
   * @schema ZoneSpecInitProvider#name
   */
  readonly name?: string;

  /**
   * Key-value map of resource tags.
   *
   * @schema ZoneSpecInitProvider#tags
   */
  readonly tags?: { [key: string]: string };

  /**
   * Configuration block(s) specifying VPC(s) to associate with a private hosted zone. Conflicts with the delegation_set_id argument in this resource and any aws_route53_zone_association resource specifying the same zone ID. Detailed below.
   *
   * @schema ZoneSpecInitProvider#vpc
   */
  readonly vpc?: ZoneSpecInitProviderVpc[];

}

/**
 * Converts an object of type 'ZoneSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProvider(obj: ZoneSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'comment': obj.comment,
    'delegationSetId': obj.delegationSetId,
    'delegationSetIdRef': toJson_ZoneSpecInitProviderDelegationSetIdRef(obj.delegationSetIdRef),
    'delegationSetIdSelector': toJson_ZoneSpecInitProviderDelegationSetIdSelector(obj.delegationSetIdSelector),
    'forceDestroy': obj.forceDestroy,
    'name': obj.name,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'vpc': obj.vpc?.map(y => toJson_ZoneSpecInitProviderVpc(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ZoneSpecManagementPolicies
 */
export enum ZoneSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ZoneSpecProviderConfigRef
 */
export interface ZoneSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecProviderConfigRef#policy
   */
  readonly policy?: ZoneSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRef(obj: ZoneSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ZoneSpecPublishConnectionDetailsTo
 */
export interface ZoneSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ZoneSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ZoneSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ZoneSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsTo(obj: ZoneSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ZoneSpecWriteConnectionSecretToRef
 */
export interface ZoneSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ZoneSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ZoneSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecWriteConnectionSecretToRef(obj: ZoneSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DelegationSet in route53 to populate delegationSetId.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRef
 */
export interface ZoneSpecForProviderDelegationSetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRef#policy
   */
  readonly policy?: ZoneSpecForProviderDelegationSetIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdRef(obj: ZoneSpecForProviderDelegationSetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecForProviderDelegationSetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DelegationSet in route53 to populate delegationSetId.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelector
 */
export interface ZoneSpecForProviderDelegationSetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelector#policy
   */
  readonly policy?: ZoneSpecForProviderDelegationSetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdSelector(obj: ZoneSpecForProviderDelegationSetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecForProviderDelegationSetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecForProviderVpc
 */
export interface ZoneSpecForProviderVpc {
  /**
   * ID of the VPC to associate.
   *
   * @schema ZoneSpecForProviderVpc#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecForProviderVpc#vpcIdRef
   */
  readonly vpcIdRef?: ZoneSpecForProviderVpcVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecForProviderVpc#vpcIdSelector
   */
  readonly vpcIdSelector?: ZoneSpecForProviderVpcVpcIdSelector;

  /**
   * Region of the VPC to associate. Defaults to AWS provider region.
   *
   * @default AWS provider region.
   * @schema ZoneSpecForProviderVpc#vpcRegion
   */
  readonly vpcRegion?: string;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpc(obj: ZoneSpecForProviderVpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ZoneSpecForProviderVpcVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ZoneSpecForProviderVpcVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a DelegationSet in route53 to populate delegationSetId.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdRef
 */
export interface ZoneSpecInitProviderDelegationSetIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdRef#policy
   */
  readonly policy?: ZoneSpecInitProviderDelegationSetIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderDelegationSetIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderDelegationSetIdRef(obj: ZoneSpecInitProviderDelegationSetIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecInitProviderDelegationSetIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a DelegationSet in route53 to populate delegationSetId.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdSelector
 */
export interface ZoneSpecInitProviderDelegationSetIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdSelector#policy
   */
  readonly policy?: ZoneSpecInitProviderDelegationSetIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderDelegationSetIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderDelegationSetIdSelector(obj: ZoneSpecInitProviderDelegationSetIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecInitProviderDelegationSetIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ZoneSpecInitProviderVpc
 */
export interface ZoneSpecInitProviderVpc {
  /**
   * ID of the VPC to associate.
   *
   * @schema ZoneSpecInitProviderVpc#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecInitProviderVpc#vpcIdRef
   */
  readonly vpcIdRef?: ZoneSpecInitProviderVpcVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneSpecInitProviderVpc#vpcIdSelector
   */
  readonly vpcIdSelector?: ZoneSpecInitProviderVpcVpcIdSelector;

  /**
   * Region of the VPC to associate. Defaults to AWS provider region.
   *
   * @default AWS provider region.
   * @schema ZoneSpecInitProviderVpc#vpcRegion
   */
  readonly vpcRegion?: string;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderVpc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderVpc(obj: ZoneSpecInitProviderVpc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ZoneSpecInitProviderVpcVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ZoneSpecInitProviderVpcVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecProviderConfigRefPolicy
 */
export interface ZoneSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecProviderConfigRefPolicy(obj: ZoneSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRef
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ZoneSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRef(obj: ZoneSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ZoneSpecPublishConnectionDetailsToMetadata
 */
export interface ZoneSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ZoneSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToMetadata(obj: ZoneSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicy
 */
export interface ZoneSpecForProviderDelegationSetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderDelegationSetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecForProviderDelegationSetIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderDelegationSetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdRefPolicy(obj: ZoneSpecForProviderDelegationSetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy
 */
export interface ZoneSpecForProviderDelegationSetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderDelegationSetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderDelegationSetIdSelectorPolicy(obj: ZoneSpecForProviderDelegationSetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRef
 */
export interface ZoneSpecForProviderVpcVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRef#policy
   */
  readonly policy?: ZoneSpecForProviderVpcVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdRef(obj: ZoneSpecForProviderVpcVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecForProviderVpcVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelector
 */
export interface ZoneSpecForProviderVpcVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelector#policy
   */
  readonly policy?: ZoneSpecForProviderVpcVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdSelector(obj: ZoneSpecForProviderVpcVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecForProviderVpcVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdRefPolicy
 */
export interface ZoneSpecInitProviderDelegationSetIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecInitProviderDelegationSetIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecInitProviderDelegationSetIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderDelegationSetIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderDelegationSetIdRefPolicy(obj: ZoneSpecInitProviderDelegationSetIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdSelectorPolicy
 */
export interface ZoneSpecInitProviderDelegationSetIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecInitProviderDelegationSetIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderDelegationSetIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderDelegationSetIdSelectorPolicy(obj: ZoneSpecInitProviderDelegationSetIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdRef
 */
export interface ZoneSpecInitProviderVpcVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdRef#policy
   */
  readonly policy?: ZoneSpecInitProviderVpcVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderVpcVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderVpcVpcIdRef(obj: ZoneSpecInitProviderVpcVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneSpecInitProviderVpcVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdSelector
 */
export interface ZoneSpecInitProviderVpcVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdSelector#policy
   */
  readonly policy?: ZoneSpecInitProviderVpcVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderVpcVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderVpcVpcIdSelector(obj: ZoneSpecInitProviderVpcVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneSpecInitProviderVpcVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolution
 */
export enum ZoneSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecProviderConfigRefPolicyResolve
 */
export enum ZoneSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ZoneSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecPublishConnectionDetailsToConfigRefPolicy(obj: ZoneSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicyResolution
 */
export enum ZoneSpecForProviderDelegationSetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecForProviderDelegationSetIdRefPolicyResolve
 */
export enum ZoneSpecForProviderDelegationSetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution
 */
export enum ZoneSpecForProviderDelegationSetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve
 */
export enum ZoneSpecForProviderDelegationSetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicy
 */
export interface ZoneSpecForProviderVpcVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderVpcVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecForProviderVpcVpcIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderVpcVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdRefPolicy(obj: ZoneSpecForProviderVpcVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy
 */
export interface ZoneSpecForProviderVpcVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecForProviderVpcVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecForProviderVpcVpcIdSelectorPolicy(obj: ZoneSpecForProviderVpcVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdRefPolicyResolution
 */
export enum ZoneSpecInitProviderDelegationSetIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdRefPolicyResolve
 */
export enum ZoneSpecInitProviderDelegationSetIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolution
 */
export enum ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolve
 */
export enum ZoneSpecInitProviderDelegationSetIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdRefPolicy
 */
export interface ZoneSpecInitProviderVpcVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdRefPolicy#resolution
   */
  readonly resolution?: ZoneSpecInitProviderVpcVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdRefPolicy#resolve
   */
  readonly resolve?: ZoneSpecInitProviderVpcVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderVpcVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderVpcVpcIdRefPolicy(obj: ZoneSpecInitProviderVpcVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdSelectorPolicy
 */
export interface ZoneSpecInitProviderVpcVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneSpecInitProviderVpcVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneSpecInitProviderVpcVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneSpecInitProviderVpcVpcIdSelectorPolicy(obj: ZoneSpecInitProviderVpcVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ZoneSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicyResolution
 */
export enum ZoneSpecForProviderVpcVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecForProviderVpcVpcIdRefPolicyResolve
 */
export enum ZoneSpecForProviderVpcVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution
 */
export enum ZoneSpecForProviderVpcVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve
 */
export enum ZoneSpecForProviderVpcVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdRefPolicyResolution
 */
export enum ZoneSpecInitProviderVpcVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdRefPolicyResolve
 */
export enum ZoneSpecInitProviderVpcVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolution
 */
export enum ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolve
 */
export enum ZoneSpecInitProviderVpcVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}


/**
 * ZoneAssociation is the Schema for the ZoneAssociations API. Manages a Route53 Hosted Zone VPC association
 *
 * @schema ZoneAssociation
 */
export class Route53ZoneAssociation extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ZoneAssociation"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'route53.aws.upbound.io/v1beta1',
    kind: 'ZoneAssociation',
  }

  /**
   * Renders a Kubernetes manifest for "ZoneAssociation".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: Route53ZoneAssociationProps): any {
    return {
      ...Route53ZoneAssociation.GVK,
      ...toJson_Route53ZoneAssociationProps(props),
    };
  }

  /**
   * Defines a "ZoneAssociation" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: Route53ZoneAssociationProps) {
    super(scope, id, {
      ...Route53ZoneAssociation.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Route53ZoneAssociation.GVK,
      ...toJson_Route53ZoneAssociationProps(resolved),
    };
  }
}

/**
 * ZoneAssociation is the Schema for the ZoneAssociations API. Manages a Route53 Hosted Zone VPC association
 *
 * @schema ZoneAssociation
 */
export interface Route53ZoneAssociationProps {
  /**
   * @schema ZoneAssociation#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ZoneAssociationSpec defines the desired state of ZoneAssociation
   *
   * @schema ZoneAssociation#spec
   */
  readonly spec: ZoneAssociationSpec;

}

/**
 * Converts an object of type 'Route53ZoneAssociationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Route53ZoneAssociationProps(obj: Route53ZoneAssociationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ZoneAssociationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ZoneAssociationSpec defines the desired state of ZoneAssociation
 *
 * @schema ZoneAssociationSpec
 */
export interface ZoneAssociationSpec {
  /**
   * DeletionPolicy specifies what will happen to the underlying external
   * when this managed resource is deleted - either "Delete" or "Orphan" the
   * external resource.
   * This field is planned to be deprecated in favor of the ManagementPolicies
   * field in a future release. Currently, both could be set independently and
   * non-default values would be honored if the feature flag is enabled.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   *
   * @schema ZoneAssociationSpec#deletionPolicy
   */
  readonly deletionPolicy?: ZoneAssociationSpecDeletionPolicy;

  /**
   * @schema ZoneAssociationSpec#forProvider
   */
  readonly forProvider: ZoneAssociationSpecForProvider;

  /**
   * THIS IS A BETA FIELD. It will be honored
   * unless the Management Policies feature flag is disabled.
   * InitProvider holds the same fields as ForProvider, with the exception
   * of Identifier and other resource reference fields. The fields that are
   * in InitProvider are merged into ForProvider when the resource is created.
   * The same fields are also added to the terraform ignore_changes hook, to
   * avoid updating them after creation. This is useful for fields that are
   * required on creation, but we do not desire to update them after creation,
   * for example because of an external controller is managing them, like an
   * autoscaler.
   *
   * @schema ZoneAssociationSpec#initProvider
   */
  readonly initProvider?: ZoneAssociationSpecInitProvider;

  /**
   * THIS IS A BETA FIELD. It is on by default but can be opted out
   * through a Crossplane feature flag.
   * ManagementPolicies specify the array of actions Crossplane is allowed to
   * take on the managed and external resources.
   * This field is planned to replace the DeletionPolicy field in a future
   * release. Currently, both could be set independently and non-default
   * values would be honored if the feature flag is enabled. If both are
   * custom, the DeletionPolicy field will be ignored.
   * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
   * and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md
   *
   * @schema ZoneAssociationSpec#managementPolicies
   */
  readonly managementPolicies?: ZoneAssociationSpecManagementPolicies[];

  /**
   * ProviderConfigReference specifies how the provider that will be used to
   * create, observe, update, and delete this managed resource should be
   * configured.
   *
   * @schema ZoneAssociationSpec#providerConfigRef
   */
  readonly providerConfigRef?: ZoneAssociationSpecProviderConfigRef;

  /**
   * PublishConnectionDetailsTo specifies the connection secret config which
   * contains a name, metadata and a reference to secret store config to
   * which any connection details for this managed resource should be written.
   * Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   *
   * @schema ZoneAssociationSpec#publishConnectionDetailsTo
   */
  readonly publishConnectionDetailsTo?: ZoneAssociationSpecPublishConnectionDetailsTo;

  /**
   * WriteConnectionSecretToReference specifies the namespace and name of a
   * Secret to which any connection details for this managed resource should
   * be written. Connection details frequently include the endpoint, username,
   * and password required to connect to the managed resource.
   * This field is planned to be replaced in a future release in favor of
   * PublishConnectionDetailsTo. Currently, both could be set independently
   * and connection details would be published to both without affecting
   * each other.
   *
   * @schema ZoneAssociationSpec#writeConnectionSecretToRef
   */
  readonly writeConnectionSecretToRef?: ZoneAssociationSpecWriteConnectionSecretToRef;

}

/**
 * Converts an object of type 'ZoneAssociationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpec(obj: ZoneAssociationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deletionPolicy': obj.deletionPolicy,
    'forProvider': toJson_ZoneAssociationSpecForProvider(obj.forProvider),
    'initProvider': toJson_ZoneAssociationSpecInitProvider(obj.initProvider),
    'managementPolicies': obj.managementPolicies?.map(y => y),
    'providerConfigRef': toJson_ZoneAssociationSpecProviderConfigRef(obj.providerConfigRef),
    'publishConnectionDetailsTo': toJson_ZoneAssociationSpecPublishConnectionDetailsTo(obj.publishConnectionDetailsTo),
    'writeConnectionSecretToRef': toJson_ZoneAssociationSpecWriteConnectionSecretToRef(obj.writeConnectionSecretToRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * DeletionPolicy specifies what will happen to the underlying external
 * when this managed resource is deleted - either "Delete" or "Orphan" the
 * external resource.
 * This field is planned to be deprecated in favor of the ManagementPolicies
 * field in a future release. Currently, both could be set independently and
 * non-default values would be honored if the feature flag is enabled.
 * See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223
 *
 * @schema ZoneAssociationSpecDeletionPolicy
 */
export enum ZoneAssociationSpecDeletionPolicy {
  /** Orphan */
  ORPHAN = "Orphan",
  /** Delete */
  DELETE = "Delete",
}

/**
 * @schema ZoneAssociationSpecForProvider
 */
export interface ZoneAssociationSpecForProvider {
  /**
   * Region is the region you'd like your resource to be created in.
   *
   * @schema ZoneAssociationSpecForProvider#region
   */
  readonly region: string;

  /**
   * The VPC to associate with the private hosted zone.
   *
   * @schema ZoneAssociationSpecForProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneAssociationSpecForProvider#vpcIdRef
   */
  readonly vpcIdRef?: ZoneAssociationSpecForProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneAssociationSpecForProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: ZoneAssociationSpecForProviderVpcIdSelector;

  /**
   * The VPC's region. Defaults to the region of the AWS provider.
   *
   * @default the region of the AWS provider.
   * @schema ZoneAssociationSpecForProvider#vpcRegion
   */
  readonly vpcRegion?: string;

  /**
   * The private hosted zone to associate.
   *
   * @schema ZoneAssociationSpecForProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema ZoneAssociationSpecForProvider#zoneIdRef
   */
  readonly zoneIdRef?: ZoneAssociationSpecForProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema ZoneAssociationSpecForProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: ZoneAssociationSpecForProviderZoneIdSelector;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProvider(obj: ZoneAssociationSpecForProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'region': obj.region,
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ZoneAssociationSpecForProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ZoneAssociationSpecForProviderVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_ZoneAssociationSpecForProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_ZoneAssociationSpecForProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * THIS IS A BETA FIELD. It will be honored
 * unless the Management Policies feature flag is disabled.
 * InitProvider holds the same fields as ForProvider, with the exception
 * of Identifier and other resource reference fields. The fields that are
 * in InitProvider are merged into ForProvider when the resource is created.
 * The same fields are also added to the terraform ignore_changes hook, to
 * avoid updating them after creation. This is useful for fields that are
 * required on creation, but we do not desire to update them after creation,
 * for example because of an external controller is managing them, like an
 * autoscaler.
 *
 * @schema ZoneAssociationSpecInitProvider
 */
export interface ZoneAssociationSpecInitProvider {
  /**
   * The VPC to associate with the private hosted zone.
   *
   * @schema ZoneAssociationSpecInitProvider#vpcId
   */
  readonly vpcId?: string;

  /**
   * Reference to a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneAssociationSpecInitProvider#vpcIdRef
   */
  readonly vpcIdRef?: ZoneAssociationSpecInitProviderVpcIdRef;

  /**
   * Selector for a VPC in ec2 to populate vpcId.
   *
   * @schema ZoneAssociationSpecInitProvider#vpcIdSelector
   */
  readonly vpcIdSelector?: ZoneAssociationSpecInitProviderVpcIdSelector;

  /**
   * The VPC's region. Defaults to the region of the AWS provider.
   *
   * @default the region of the AWS provider.
   * @schema ZoneAssociationSpecInitProvider#vpcRegion
   */
  readonly vpcRegion?: string;

  /**
   * The private hosted zone to associate.
   *
   * @schema ZoneAssociationSpecInitProvider#zoneId
   */
  readonly zoneId?: string;

  /**
   * Reference to a Zone in route53 to populate zoneId.
   *
   * @schema ZoneAssociationSpecInitProvider#zoneIdRef
   */
  readonly zoneIdRef?: ZoneAssociationSpecInitProviderZoneIdRef;

  /**
   * Selector for a Zone in route53 to populate zoneId.
   *
   * @schema ZoneAssociationSpecInitProvider#zoneIdSelector
   */
  readonly zoneIdSelector?: ZoneAssociationSpecInitProviderZoneIdSelector;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProvider' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProvider(obj: ZoneAssociationSpecInitProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'vpcId': obj.vpcId,
    'vpcIdRef': toJson_ZoneAssociationSpecInitProviderVpcIdRef(obj.vpcIdRef),
    'vpcIdSelector': toJson_ZoneAssociationSpecInitProviderVpcIdSelector(obj.vpcIdSelector),
    'vpcRegion': obj.vpcRegion,
    'zoneId': obj.zoneId,
    'zoneIdRef': toJson_ZoneAssociationSpecInitProviderZoneIdRef(obj.zoneIdRef),
    'zoneIdSelector': toJson_ZoneAssociationSpecInitProviderZoneIdSelector(obj.zoneIdSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A ManagementAction represents an action that the Crossplane controllers
 * can take on an external resource.
 *
 * @schema ZoneAssociationSpecManagementPolicies
 */
export enum ZoneAssociationSpecManagementPolicies {
  /** Observe */
  OBSERVE = "Observe",
  /** Create */
  CREATE = "Create",
  /** Update */
  UPDATE = "Update",
  /** Delete */
  DELETE = "Delete",
  /** LateInitialize */
  LATE_INITIALIZE = "LateInitialize",
  /** * */
  VALUE_ASTERISK = "*",
}

/**
 * ProviderConfigReference specifies how the provider that will be used to
 * create, observe, update, and delete this managed resource should be
 * configured.
 *
 * @schema ZoneAssociationSpecProviderConfigRef
 */
export interface ZoneAssociationSpecProviderConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecProviderConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecProviderConfigRef#policy
   */
  readonly policy?: ZoneAssociationSpecProviderConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecProviderConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecProviderConfigRef(obj: ZoneAssociationSpecProviderConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecProviderConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PublishConnectionDetailsTo specifies the connection secret config which
 * contains a name, metadata and a reference to secret store config to
 * which any connection details for this managed resource should be written.
 * Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsTo
 */
export interface ZoneAssociationSpecPublishConnectionDetailsTo {
  /**
   * SecretStoreConfigRef specifies which secret store config should be used
   * for this ConnectionSecret.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsTo#configRef
   */
  readonly configRef?: ZoneAssociationSpecPublishConnectionDetailsToConfigRef;

  /**
   * Metadata is the metadata for connection secret.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsTo#metadata
   */
  readonly metadata?: ZoneAssociationSpecPublishConnectionDetailsToMetadata;

  /**
   * Name is the name of the connection secret.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsTo#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ZoneAssociationSpecPublishConnectionDetailsTo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecPublishConnectionDetailsTo(obj: ZoneAssociationSpecPublishConnectionDetailsTo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configRef': toJson_ZoneAssociationSpecPublishConnectionDetailsToConfigRef(obj.configRef),
    'metadata': toJson_ZoneAssociationSpecPublishConnectionDetailsToMetadata(obj.metadata),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WriteConnectionSecretToReference specifies the namespace and name of a
 * Secret to which any connection details for this managed resource should
 * be written. Connection details frequently include the endpoint, username,
 * and password required to connect to the managed resource.
 * This field is planned to be replaced in a future release in favor of
 * PublishConnectionDetailsTo. Currently, both could be set independently
 * and connection details would be published to both without affecting
 * each other.
 *
 * @schema ZoneAssociationSpecWriteConnectionSecretToRef
 */
export interface ZoneAssociationSpecWriteConnectionSecretToRef {
  /**
   * Name of the secret.
   *
   * @schema ZoneAssociationSpecWriteConnectionSecretToRef#name
   */
  readonly name: string;

  /**
   * Namespace of the secret.
   *
   * @schema ZoneAssociationSpecWriteConnectionSecretToRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'ZoneAssociationSpecWriteConnectionSecretToRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecWriteConnectionSecretToRef(obj: ZoneAssociationSpecWriteConnectionSecretToRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdRef
 */
export interface ZoneAssociationSpecForProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdRef#policy
   */
  readonly policy?: ZoneAssociationSpecForProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderVpcIdRef(obj: ZoneAssociationSpecForProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecForProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdSelector
 */
export interface ZoneAssociationSpecForProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdSelector#policy
   */
  readonly policy?: ZoneAssociationSpecForProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderVpcIdSelector(obj: ZoneAssociationSpecForProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneAssociationSpecForProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdRef
 */
export interface ZoneAssociationSpecForProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdRef#policy
   */
  readonly policy?: ZoneAssociationSpecForProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderZoneIdRef(obj: ZoneAssociationSpecForProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecForProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdSelector
 */
export interface ZoneAssociationSpecForProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdSelector#policy
   */
  readonly policy?: ZoneAssociationSpecForProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderZoneIdSelector(obj: ZoneAssociationSpecForProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneAssociationSpecForProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdRef
 */
export interface ZoneAssociationSpecInitProviderVpcIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdRef#policy
   */
  readonly policy?: ZoneAssociationSpecInitProviderVpcIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderVpcIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderVpcIdRef(obj: ZoneAssociationSpecInitProviderVpcIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecInitProviderVpcIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a VPC in ec2 to populate vpcId.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdSelector
 */
export interface ZoneAssociationSpecInitProviderVpcIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdSelector#policy
   */
  readonly policy?: ZoneAssociationSpecInitProviderVpcIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderVpcIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderVpcIdSelector(obj: ZoneAssociationSpecInitProviderVpcIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneAssociationSpecInitProviderVpcIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a Zone in route53 to populate zoneId.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdRef
 */
export interface ZoneAssociationSpecInitProviderZoneIdRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdRef#policy
   */
  readonly policy?: ZoneAssociationSpecInitProviderZoneIdRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderZoneIdRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderZoneIdRef(obj: ZoneAssociationSpecInitProviderZoneIdRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecInitProviderZoneIdRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector for a Zone in route53 to populate zoneId.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdSelector
 */
export interface ZoneAssociationSpecInitProviderZoneIdSelector {
  /**
   * MatchControllerRef ensures an object with the same controller reference
   * as the selecting object is selected.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdSelector#matchControllerRef
   */
  readonly matchControllerRef?: boolean;

  /**
   * MatchLabels ensures an object with matching labels is selected.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Policies for selection.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdSelector#policy
   */
  readonly policy?: ZoneAssociationSpecInitProviderZoneIdSelectorPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderZoneIdSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderZoneIdSelector(obj: ZoneAssociationSpecInitProviderZoneIdSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchControllerRef': obj.matchControllerRef,
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'policy': toJson_ZoneAssociationSpecInitProviderZoneIdSelectorPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecProviderConfigRefPolicy
 */
export interface ZoneAssociationSpecProviderConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecProviderConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecProviderConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecProviderConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecProviderConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecProviderConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecProviderConfigRefPolicy(obj: ZoneAssociationSpecProviderConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretStoreConfigRef specifies which secret store config should be used
 * for this ConnectionSecret.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRef
 */
export interface ZoneAssociationSpecPublishConnectionDetailsToConfigRef {
  /**
   * Name of the referenced object.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRef#name
   */
  readonly name: string;

  /**
   * Policies for referencing.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRef#policy
   */
  readonly policy?: ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy;

}

/**
 * Converts an object of type 'ZoneAssociationSpecPublishConnectionDetailsToConfigRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecPublishConnectionDetailsToConfigRef(obj: ZoneAssociationSpecPublishConnectionDetailsToConfigRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'policy': toJson_ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj.policy),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata is the metadata for connection secret.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsToMetadata
 */
export interface ZoneAssociationSpecPublishConnectionDetailsToMetadata {
  /**
   * Annotations are the annotations to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.annotations".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels are the labels/tags to be added to connection secret.
   * - For Kubernetes secrets, this will be used as "metadata.labels".
   * - It is up to Secret Store implementation for others store types.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToMetadata#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Type is the SecretType for the connection secret.
   * - Only valid for Kubernetes Secret Stores.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToMetadata#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ZoneAssociationSpecPublishConnectionDetailsToMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecPublishConnectionDetailsToMetadata(obj: ZoneAssociationSpecPublishConnectionDetailsToMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdRefPolicy
 */
export interface ZoneAssociationSpecForProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecForProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecForProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderVpcIdRefPolicy(obj: ZoneAssociationSpecForProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdSelectorPolicy
 */
export interface ZoneAssociationSpecForProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecForProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderVpcIdSelectorPolicy(obj: ZoneAssociationSpecForProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdRefPolicy
 */
export interface ZoneAssociationSpecForProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecForProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecForProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderZoneIdRefPolicy(obj: ZoneAssociationSpecForProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdSelectorPolicy
 */
export interface ZoneAssociationSpecForProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecForProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecForProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecForProviderZoneIdSelectorPolicy(obj: ZoneAssociationSpecForProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdRefPolicy
 */
export interface ZoneAssociationSpecInitProviderVpcIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecInitProviderVpcIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecInitProviderVpcIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderVpcIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderVpcIdRefPolicy(obj: ZoneAssociationSpecInitProviderVpcIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdSelectorPolicy
 */
export interface ZoneAssociationSpecInitProviderVpcIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecInitProviderVpcIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderVpcIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderVpcIdSelectorPolicy(obj: ZoneAssociationSpecInitProviderVpcIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdRefPolicy
 */
export interface ZoneAssociationSpecInitProviderZoneIdRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecInitProviderZoneIdRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecInitProviderZoneIdRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderZoneIdRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderZoneIdRefPolicy(obj: ZoneAssociationSpecInitProviderZoneIdRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Policies for selection.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdSelectorPolicy
 */
export interface ZoneAssociationSpecInitProviderZoneIdSelectorPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdSelectorPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecInitProviderZoneIdSelectorPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecInitProviderZoneIdSelectorPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecInitProviderZoneIdSelectorPolicy(obj: ZoneAssociationSpecInitProviderZoneIdSelectorPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecProviderConfigRefPolicyResolution
 */
export enum ZoneAssociationSpecProviderConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecProviderConfigRefPolicyResolve
 */
export enum ZoneAssociationSpecProviderConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Policies for referencing.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy
 */
export interface ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy {
  /**
   * Resolution specifies whether resolution of this reference is required.
   * The default is 'Required', which means the reconcile will fail if the
   * reference cannot be resolved. 'Optional' means this reference will be
   * a no-op if it cannot be resolved.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolution
   */
  readonly resolution?: ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution;

  /**
   * Resolve specifies when this reference should be resolved. The default
   * is 'IfNotPresent', which will attempt to resolve the reference only when
   * the corresponding field is not present. Use 'Always' to resolve the
   * reference on every reconcile.
   *
   * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy#resolve
   */
  readonly resolve?: ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve;

}

/**
 * Converts an object of type 'ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy(obj: ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'resolution': obj.resolution,
    'resolve': obj.resolve,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdRefPolicyResolution
 */
export enum ZoneAssociationSpecForProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdRefPolicyResolve
 */
export enum ZoneAssociationSpecForProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolution
 */
export enum ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolve
 */
export enum ZoneAssociationSpecForProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdRefPolicyResolution
 */
export enum ZoneAssociationSpecForProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdRefPolicyResolve
 */
export enum ZoneAssociationSpecForProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolution
 */
export enum ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolve
 */
export enum ZoneAssociationSpecForProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdRefPolicyResolution
 */
export enum ZoneAssociationSpecInitProviderVpcIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdRefPolicyResolve
 */
export enum ZoneAssociationSpecInitProviderVpcIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolution
 */
export enum ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolve
 */
export enum ZoneAssociationSpecInitProviderVpcIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdRefPolicyResolution
 */
export enum ZoneAssociationSpecInitProviderZoneIdRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdRefPolicyResolve
 */
export enum ZoneAssociationSpecInitProviderZoneIdRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolution
 */
export enum ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolve
 */
export enum ZoneAssociationSpecInitProviderZoneIdSelectorPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

/**
 * Resolution specifies whether resolution of this reference is required.
 * The default is 'Required', which means the reconcile will fail if the
 * reference cannot be resolved. 'Optional' means this reference will be
 * a no-op if it cannot be resolved.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution
 */
export enum ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolution {
  /** Required */
  REQUIRED = "Required",
  /** Optional */
  OPTIONAL = "Optional",
}

/**
 * Resolve specifies when this reference should be resolved. The default
 * is 'IfNotPresent', which will attempt to resolve the reference only when
 * the corresponding field is not present. Use 'Always' to resolve the
 * reference on every reconcile.
 *
 * @schema ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve
 */
export enum ZoneAssociationSpecPublishConnectionDetailsToConfigRefPolicyResolve {
  /** Always */
  ALWAYS = "Always",
  /** IfNotPresent */
  IF_NOT_PRESENT = "IfNotPresent",
}

